/* autogenerated by webmerge (join context) */
;
/*
Astronomical Calculations (https://github.com/mgreter/astro.js)
- Copyright (c) 2017 Marcel Greter (http://github.com/mgreter)
*/;
/* Vector3 implementation included */;
(function(window) {;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 */

if (typeof window.THREE == 'undefined') {
	window.THREE = {};
}

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};


THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	},


	add: function ( v1, v2 ) {

		this.x = v1.x + v2.x;
		this.y = v1.y + v2.y;
		this.z = v1.z + v2.z;

		return this;

	},

	addSelf: function ( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	sub: function ( v1, v2 ) {

		this.x = v1.x - v2.x;
		this.y = v1.y - v2.y;
		this.z = v1.z - v2.z;

		return this;

	},

	subSelf: function ( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	multiply: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	multiplySelf: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;
		this.z *= s;

		return this;

	},

	divideSelf: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s ) {

			this.x /= s;
			this.y /= s;
			this.z /= s;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},


	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.lengthSq() );

	},

	lengthManhattan: function () {

		// correct version
		// return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		return this.x + this.y + this.z;

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		return this.normalize().multiplyScalar( l );

	},


	cross: function ( a, b ) {

		this.x = a.y * b.z - a.z * b.y;
		this.y = a.z * b.x - a.x * b.z;
		this.z = a.x * b.y - a.y * b.x;

		return this;

	},

	crossSelf: function ( v ) {

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},


	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		return new THREE.Vector3().sub( this, v ).lengthSq();

	},


	setPositionFromMatrix: function ( m ) {

		this.x = m.n14;
		this.y = m.n24;
		this.z = m.n34;

	},

	setRotationFromMatrix: function ( m ) {

		var cosY = Math.cos( this.y );

		this.y = Math.asin( m.n13 );

		if ( Math.abs( cosY ) > 0.00001 ) {

			this.x = Math.atan2( - m.n23 / cosY, m.n33 / cosY );
			this.z = Math.atan2( - m.n12 / cosY, m.n11 / cosY );

		} else {

			this.x = 0;
			this.z = Math.atan2( m.n21, m.n22 );

		}

	},

	isZero: function () {

		return ( this.lengthSq() < 0.0001 /* almostZero */ );

	}

};

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function projectOnVector( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setFromSpherical: function( s ) {

		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		return this.setFromMatrixColumn( m, 3 );

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		if ( typeof m === 'number' ) {

			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );

			m = arguments[ 1 ];
			index = arguments[ 0 ];

		}

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];

		return this;

	}

};
;
// global constants for math operations
// should probably put into a namespace

// astronomical units to meters
var AU2M = 1.495978707e+11;
var M2AU = 1 / AU2M;

var AU2KM = AU2M / 1000;
var KM2AU = M2AU * 1000;

// metric conversion
var KM2M = 1000;
var M2KM = 1 / KM2M;

// exponential factors
var KM2AU2 = KM2AU * KM2AU;
var KM2AU3 = KM2AU2 * KM2AU;

// J2000 epoch in JD
var T2K = 2451545.0; // TT

// julian day conversion
var JY2JD = 365.25;
var JD2JY = 1 / JY2JD;

// time conversion
var DAY2SEC = 24*60*60;
var SEC2DAY = 1 / DAY2SEC;

// solar mass conversion
var MSOL2KG = 1.98855e30;
var KG2MSOL = 1 / MSOL2KG;

// Julian Days to J2000
function JD2J2K (JD)
{
	// offset epoch and add ratio
	return (JD - T2K) / JY2JD;
}

// J2000 to Julian Days
function J2K2JD (J2K)
{
	// add ratio and offset epoch
	return J2K * JY2JD + T2K;
}

// Gravitational parameters for astronomic scale
// time in days, distance in AU, mass in sun-mass
// http://astronomy.stackexchange.com/a/7981
// GM * M2AU^3 * DAY2SEC^2 * MSOL2KG
var GMP = {
	sun: 2.9591220836841438269e-04, // sun
	mer: 4.9125474514508118699e-11, // mer
	ven: 7.2434524861627027000e-10, // ven
	ear: 8.9970116036316091182e-10, // ear
	emb: 8.9970116036316091182e-10, // emb
	mar: 9.5495351057792580598e-11, // mar
	jup: 2.8253458420837780000e-07, // jup
	sat: 8.4597151856806587398e-08, // sat
	ura: 1.2920249167819693900e-08, // ura
	nep: 1.5243589007842762800e-08, // nep
	plu: 2.1886997654259696800e-12 // plu
};

// maximum iterations to find
// a value in range for epsilon
// used in Newton-Raphson solver
var MAXLOOP = 12;
var EPSILON = 1e-12;

// use TAU, PI is wrong
var PI = 1 * Math.PI;
var TAU = 2 * Math.PI;

// trig conversion factors
var DEG2RAD = TAU / 360;
var RAD2DEG = 360 / TAU;
var HMS2RAD = TAU / 24;
var RAD2HMS = 24 / TAU;
var HMS2DEG = 360 / 24;
var DEG2HMS = 24 / 360;

// from 0 to TAU
// one full cycle
function CYCLE(rad) {
	rad %= TAU;
	if (rad < 0)
		rad += TAU;
	return rad;
}

// from -PI to +PI
// turn left/right
function TURN(rad) {
	rad %= TAU;
	if (rad > PI)
		rad -= TAU;
	return rad;
}

// polyfill for cube root function
// from https://developer.mozilla.org
Math.cbrt = Math.cbrt || function(x) {
	var y = Math.pow(Math.abs(x), 1/3);
	return x < 0 ? -y : y;
};

// THREE.Vector3 compatible implementation
if (typeof THREE != "undefined") {
	window.Vector3 = THREE.Vector3;
};
/*############################################################################*/
// AstroJS Orbit Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/
// http://www.lns.cornell.edu/~seb/celestia/orbital-parameters.html
// Similar module: https://github.com/jordanstephens/kepler.js
/*############################################################################*/
'use strict';

(function (exports) {

	/******************************************************************************/
	// Orbits can be created from orbital elements (6 independent parameters)
	// or from state vectors (position and velocity). In both cases we need 6
	// arguments to fully define an orbit. Most related parameters will be
	// calculated on construction. But certain parameters as the true anomaly
	// are a bit more complex to calculate from orbital elements, if only the
	// mean anomaly is given as initial parameters. They are lazy calculated
	// on demand, either by using the getter or invoking updateElements(true).
	/******************************************************************************/
	// To get state vectors for different times we just add a linear factor
	// to the mean anomaly (related to mean motion and period). To get the
	// actual state vectors from the mean anomaly we need to compute the
	// solution for Kepler's Equation via Newton-Raphson solver loop.
	/******************************************************************************/
	// Keep in mind that all angular parameters are in rads and that all
	// other units are linked to each other. This means that you can change
	// the units by adjusting the gravitational parameter. We use the solar
	// gravitational parameter by default with the units: au^3/(solm*day^2).
	// Normally in physics this parameter is measured in m^3/(kg*s^2). All
	// distance and time units must therefore be in the same units as `G`.
	/******************************************************************************/
	// ToDo: finish and add tests for circular and hyperbola orbits.
	/******************************************************************************/

	function Orbit(arg)
	{

		// internal use
		if (arg.empty) {
			return this;
		}

		// the gravitational parameter is very important and must
		// match all others in terms of the units. In physics the
		// units are by default m^3/(kg*s^2), but for astronomical
		// uses we most often want to use au^3/(solm*day^2).
		this._G = GMP.sun;

		// create state vectors from input parameters
		if ('x' in arg && 'y' in arg && 'z' in arg) {
			this._r = new Vector3(arg.x, arg.y, arg.z);
		}
		else if ('rx' in arg && 'ry' in arg && 'rz' in arg) {
			this._r = new Vector3(arg.rx, arg.ry, arg.rz);
		}
		if ('X' in arg && 'Y' in arg && 'Z' in arg) {
			this._v = new Vector3(arg.X, arg.Y, arg.Z);
		}
		else if ('vx' in arg && 'vy' in arg && 'vz' in arg) {
			this._v = new Vector3(arg.vx, arg.vy, arg.vz);
		}

		if ('r' in arg && 'v' in arg) {
			var r = arg.r, v = arg.v;
			// create new vectors (want a clone anyway)
			this._r = new Vector3(r.x, r.y, r.z);
			this._v = new Vector3(v.x, v.y, v.z);
		}

		// set status for state vectors
		this.vectors = !!(this._r && this._v);

		// get other parameters from arg
		// unknown parameters are ignored
		var vars = 'aeiMnPLcCwWOkhqpG'.split('');
		for (var i in vars) {
			if (arg.hasOwnProperty(vars[i])) {
				this['_' + vars[i]] = arg[vars[i]];
			}
		}

		// orbit may has name
		if ('name' in arg) {
			this.name = arg.name;
		}

		// resolve if not lazy
		if (!this.lazy) {
			this.updateElements();
			this.requireElements();
		}

	}
	// EO Orbit ctor

	// optimized for minifier
	var Klass = Orbit.prototype;

	/******************************************************************************/
	// clone the existing orbital
	/******************************************************************************/

	// copy existing orbit and return clone
	Klass.clone = function clone(dt)
	{
		// create an empty object (internal use)
		var clone = new Orbit({ empty: true });
		// avoid unnecessary cloning of objects
		if (dt) { delete this._v; delete this._r; }
		// process all properties
		for (var key in this) {
			if (this.hasOwnProperty(key)) {
				// invoke nested clone functions (vectors)
				if (typeof this[key].clone == 'function')
				{ clone[key] = this[key].clone(); }
				else { clone[key] = this[key]; }
			}
		}
		// optionally call update
		if (dt) clone.update(dt);
		// return copy
		return clone;
	}

	/******************************************************************************/
	// check current object for valid resolved state
	/******************************************************************************/
	Klass.checkElements = function checkElements(full)
	{
		// most basic check for initial pre-calculations
		if (!this.elements) throw('Orbitals not calculated');
		// do some basic checks for needed orbital elements
		if (!('_i' in this)) throw('Orbit is missing inclination (i)');
		if (!('_e' in this)) throw('Orbit is missing eccentricity (e)');
		if (!('_a' in this)) throw('Orbit is missing semi-major axis (a)');
		if (!('_b' in this)) throw('Orbit is missing semi-minor axis (b)');
		if (!('_l' in this)) throw('Orbit is missing semi-latus rectum (l)');
		if (!('_c' in this)) throw('Orbit is missing periapsis (c)');
		if (!('_C' in this)) throw('Orbit is missing apoapsis (C)');
		if (!('_L' in this)) throw('Orbit is missing mean longitude (L)');
		if (!('_O' in this)) throw('Orbit is missing right ascending node (O)');
		if (!('_T' in this)) throw('Orbit is missing time of periapsis (w)');
		if (!('_w' in this)) throw('Orbit is missing argument of periapsis (w)');
		if (!('_W' in this)) throw('Orbit is missing longitude of the periapsis (W)');
		if (!('_n' in this)) throw('Orbit is missing mean motion (n)');
		if (!('_M' in this)) throw('Orbit is missing mean anomaly (M)');
		if (!('_P' in this)) throw('Orbit is missing orbital period (P)');
		if (!('_A' in this)) throw('Orbit is missing angular momentum (A)');
		if (!('_c' in this)) throw('Orbit is missing pericenter (c)');
		if (!('_C' in this)) throw('Orbit is missing apocenter (C)');
		// state vectors (r and v) are not tested here ...
		if (full) if (!('_m' in this)) throw('Orbit is missing true anomaly (m)');
		if (full) if (!('_B' in this)) throw('Orbit is missing radial velocity (B)');
		if (full) if (!('_E' in this)) throw('Orbit is missing eccentric anomaly (E)');
	}

	/******************************************************************************/
	// ensure certain orbital elements exist: aeiWLMOw
	/******************************************************************************/
	Klass.requireElements = function requireElements(full)
	{
		// invoke resolver (fully)
		this.updateElements(full);
		this.checkElements(full);
		// chain-able
		return this;
	}

	/******************************************************************************/
	// resolve orbital elements as far as possible
	/******************************************************************************/
	Klass.updateElements = function updateElements(full)
	{

		// only resolve elements once
		if (this.elements) return this;
		// will calculate now
		this.elements = true;

		/********************************************************/
		// resolve from state vectors (r, v)
		/********************************************************/

		// check main state vectors
		if ('_r' in this && '_v' in this) {

			var r = this._r, v = this._v,
			    G = this._G, rl = r.length();

			// specific relative angular momentum
			this._A3 = r.clone().cross(v);
			this._A2 = this._A3.lengthSq();
			this._A = Math.sqrt(this._A2);
			// calculate radial velocity
			this._B = r.dot(v) / rl;

			// calculate eccentricity vector
			var e3 = this._e3 = r.clone().multiplyScalar(v.lengthSq() - (G / rl))
				.sub(v.clone().multiplyScalar(rl * this._B)).multiplyScalar(1 / G);
			// get eccentricity value from vector
			var e2 = e3.lengthSq(), e = this._e = Math.sqrt(e2);
			// get inclination (i) via orbital momentum vector
			this._i = Math.acos(this._A3.z / this._A);

			// calculate semilatus rectum (ℓ)
			this._l = this._A2 / G;
			// and periapsis (c) and apoapsis (C)
			this._c = this._l / (1 + e);
			this._C = this._l / (1 - e);
			// and finally semi-major axis (a)
			this._a = (this._C + this._c) / 2;

			// pre-calculate node line
			var nx = - this._A3.y,
			    ny = + this._A3.x;
			var nl = Math.sqrt(nx*nx + ny*ny);

			// calculate ascending node (O)
			var omega = nl == 0 ? 0 : Math.acos(nx / nl);
			this._O = ny < 0 ? (TAU - omega) : omega;

			// calculate argument of periapsis (ω)
			var nedot = nx * e3.x +
			            ny * e3.y;
			if (nl === 0 || e === 0) { this.w = 0; }
			else { this._w = Math.acos(nedot / nl / e); }
			if (e3.z < 0) { this._w *= -1; }

			// calculate true anomaly
			var u; // argument of latitude
			// case for circular orbit
			// and without inclination
			if (e === 0 && nl === 0) {
				// this needs a test case
				u = Math.acos(r.x / rl);
			}
			// circular orbit
			// with inclination
			else if (e === 0) {
				// this needs a test case
				var nrdot = nx * r.x + ny * r.y;
				u = Math.acos(nrdot / (nl * rl));
			}
			// elliptic orbit
			else {
				var redot = e3.x * r.x + e3.y * r.y + e3.z * r.z;
				u = Math.acos(redot / e / rl);
			}
			// bring into correct range via simple check
			var m = this._m = this._B < 0 ? (TAU - u) : u;

			// calculate eccentric anomaly
			var E = this._E = CYCLE(Math.atan2(
				Math.sqrt(1 - e*e) * Math.sin(m),
				e + Math.cos(m)
			));

			// calculate mean anomaly
			this._M = E - e * Math.sin(E);

		}
		// EO state vectors

		/********************************************************/
		// VSOP87 uses some exotic orbital elements
		// not sure if they have a technical name
		/********************************************************/

		// VSOP arguments (k/h -> W/e)
		// Called pi (W) in VSOP87
		// k = e*cos(W) [rad]
		// h = e*sin(W) [rad]
		if ('_k' in this && '_h' in this) {
			// periapsis longitude directly from p and q
			this._W = Math.atan2(this._h, this._k);
			// this._e = this._k / Math.cos(this._W);
			this._e = this._h / Math.sin(this._W);
		}

		// VSOP arguments (q/p -> O/i)
		// Called omega (O) in VSOP87
		// q = sin(i/2)*cos(O) [rad]
		// p = sin(i/2)*sin(O) [rad]
		if ('_q' in this && '_p' in this) {
			// ascending node directly from p and q
			this._O = Math.atan2(this._p, this._q);
			// values for inclination
			var d = this._p - this._q,
				// using the faster but equivalent form for
				// dt = Math.sin(this._O) - Math.cos(this._O);
				dt = - Math.sqrt(2) * Math.sin(PI / 4 - this._O);
			// now calculate inclination
			this._i = 2 * Math.asin(d / dt);
		}

		/********************************************************/
		// directly related parameters for a
		// more stuff is calculated later on
		/********************************************************/

		if ('_n' in this && !('_a' in this)) {
			// mean motion is translated directly to size via
			this._a = Math.cbrt(this._G / this._n / this._n);
		}
		if ('_P' in this && !('_a' in this)) {
			// period is translated directly to size via G
			var PTAU = this._P / TAU; // reuse for square
			this._a = Math.cbrt(this._G * PTAU * PTAU);
		}

		/********************************************************/
		// semi-major axis and eccentricity
		// from apocenter and pericenter
		// C = a * (1 + e), c = a * (1 - e)
		/********************************************************/
		if (!('_a' in this)) { // semi-major axis
			if ('_c' in this && '_C' in this) { this._a = (this._C + this._c) / 2; }
			else if ('_e' in this && '_C' in this) { this._a = this._C / (1 + this._e); }
			else if ('_c' in this && '_e' in this) { this._a = this._c / (1 - this._e); }
		}
		if (!('_e' in this)) { // eccentricity
			if ('_c' in this && '_C' in this) { this._e = 1 - this._c / this._a; }
			else if ('_a' in this && '_C' in this) { this._e = this._C / this._a - 1; }
			else if ('_c' in this && '_a' in this) { this._e = 1 - this._c / this._a; }
		}

		/********************************************************/
		// orbital size parameters
		// a * l = b * b
		// l = a * (1 - e*e)
		// b = a * sqrt(1 - e*e)
		// need 2 independent arguments
		// there are 6 valid combination
		/********************************************************/

		// 3 valid options with e
		if ('_e' in this) {
			var e2term = 1 - this._e * this._e;
			if ('_a' in this) {
				this._l = this._a * e2term;
				this._b = Math.sqrt(this._a * this._l);
			}
			else if ('_b' in this) {
				this._a = this._b / Math.sqrt(e2term);
				this._l = this._a * e2term;
			}
			else if ('_l' in this) {
				this._a = this._l / e2term;
				this._b = Math.sqrt(this._a * this._l);
			}
		}
		// 2 valid options with a
		else if ('_a' in this) {
			if ('_b' in this) {
				this._l = this._b * this._b / this._a;
				this._e = Math.sqrt(1 - this._l / this._a);
			}
			else if ('_l' in this) {
				this._e = Math.sqrt(1 - this._l / this._a);
				this._b = Math.sqrt(this._a * this._l);
			}
		}
		// only one valid options left
		else if ('_b' in this && '_l' in this) {
			this.a = this._b * this._b / this._l;
			this._e = Math.sqrt(1 - this._l / this._a);
		}

		// calculate orbital period (P)
		if ('_a' in this && !('_P' in this)) {
			// calculate dependants via gravitational parameter
			this._P = (TAU / Math.sqrt(this._G)) * Math.pow(this._a, 1.5);
		}
		// calculate mean motion (n)
		if ('_P' in this && !('_n' in this)) {
			this._n = TAU / this._P;
		}
		// specific relative angular momentum (A)
		if ('_P' in this && !('_A' in this)) {
			if ('_a' in this && '_b' in this) {
				this._A = TAU * this._a * this._b / this._P;
			}
		}

		// apsis from eccentricity and semi-major axis
		if ('_a' in this && '_e' in this) {
			if (!('_c' in this)) this._c = this._a * ( 1 - this._e );
			if (!('_C' in this)) this._C = this._a * ( 1 + this._e );
		}

		/********************************************************/
		// orientation parameters
		// W = L - M = O + w
		// need 3 independent arguments
		// there are 8 valid combination
		/********************************************************/

		// 5 valid options with L
		if ('_L' in this) {
			if ('_M' in this) {
				// calculate the main dependants
				this._W = this._L - this._M;
				// calculate additional dependants
				if ('_O' in this) this._w = this._W - this._O;
				else if ('_w' in this) this._O = this._W - this._w;
			}
			else if ('_W' in this) {
				// calculate the main dependants
				this._M = this._L - this._W;
				// calculate additional dependants
				if ('_O' in this) this._w = this._W - this._O;
				else if ('_w' in this) this._O = this._W - this._w;
			}
			else if ('_O' in this && '_w' in this) {
				// calculate the main dependants
				this._W = this._O + this._w;
				this._M = this._L - this._W;
			}
			else {
				throw('Orbit incomplete')
			}
		}
		// 2 valid options with O
		else if ('_O' in this) {
			if ('_w' in this) {
				// calculate the main dependants
				this._W = this._O + this._w;
				// calculate additional dependants
				if ('_M' in this) this._L = this._M + this._W;
				// the L case is already handled in the very first if
				// else if ('_L' in this) this._M = this._L - this._W;
			}
			else if ('_W' in this) {
				// calculate the main dependants
				this._w = this._W - this._O;
				// calculate additional dependants
				if ('_M' in this) this._L = this._M + this._W;
				// the L case is already handled in the very first if
				// else if ('_L' in this) this._M = this._L - this._W;
			}
			else {
				throw('Orbit incomplete')
			}
		}
		// only one valid options left
		else if ('_M' in this && '_w' in this && '_W' in this) {
			this._L = this._W + this._M;
			this._O = this._W - this._w;
		}

		/********************************************************/
		// optionally do expensive calculations
		/********************************************************/

		if (full) this.m();

		/********************************************************/
		// do range corrections
		/********************************************************/

		// bring parameters into correct ranges
		if ('_W' in this) this._W = TURN(this._W); // verified
		if ('_L' in this) this._L = CYCLE(this._L); // verified
		if ('_M' in this) this._M = CYCLE(this._M); // verified
		if ('_O' in this) this._O = CYCLE(this._O); // verified
		if ('_w' in this) this._w = TURN(this._w); // verified

		/********************************************************/
		// TODO: better time epoch support
		/********************************************************/
		if ('_M' in this && '_n') {
			this._T = - this._M / this._n;
		}

		// chain-able
		return this;

	}

	/*############################################################################*/
	// Next functions are needed to calculate eccentricity anomaly and
	// related parameter (i.e. from mean anomaly to true anomaly).
	/*############################################################################*/

	/******************************************************************************/
	// In orbital mechanics, eccentric anomaly (E) is an angular parameter that
	// defines the position of a body that is moving along an elliptic Kepler
	// orbit. The eccentric anomaly (E) is one of three angular parameters
	// ("anomalies") that define a position along an orbit, the other two
	// being the true anomaly (m) and the mean anomaly (M).
	/******************************************************************************/
	Klass.E = function eccentricAnomaly(dt)
	{

		// return cached
		if ('_E' in this && !dt) {
			return this._E;
		}

		// basic parameters
		var e = this._e, // must
		    m = this._m, // either
		    M = this._M; // ... or

		// from true anomaly (m)
		// much easier calculation
		if (!dt && e != null && m != null) {
			return this._E = CYCLE(Math.atan2(
				Math.sqrt(1 - e*e) * Math.sin(m),
				e + Math.cos(m)
			));
		}

		// from mean anomaly (M)
		// M = L - W (W = O + w)
		// more expensive solver loop
		if (e != null && M != null) {
			// advance mean anomaly for new time offset
			if (dt) M = CYCLE(this._n * (dt - this._T));
			// prepare for solution solver
			var E = e < 0.8 ? M : PI, F;
			var F = E - e * Math.sin(M) - M;
			// Newton-Raphson method to solve
			// f(E) = M - E + e * sin(E) = 0
			var f, dfdE, dE = 1;
			for (var it = 0; Math.abs(dE) > EPSILON && it < MAXLOOP; ++it) {
				f = M - E + e * Math.sin(E);
				dfdE = e * Math.cos(E) - 1.0;
				dE = f / dfdE;
				E -= dE; // next iteration
			}
			// clamp range
			E = CYCLE(E);
			// cache for zero time
			if (!dt) this._E = E;
			// return result
			return E;
		}

		// remove in release version
		throw('Invalid orbital state');

		// fail gracefully
		return null;
	}

	/******************************************************************************/
	// In celestial mechanics, true anomaly is an angular parameter that defines the
	// position of a body moving along a Keplerian orbit. It is the angle between the
	// direction of periapsis and the current position of the body, as seen from the
	// main focus of the ellipse (the point around which the object orbits).
	/******************************************************************************/
	Klass.m = function trueAnomaly(E)
	{
		if (arguments.length === 0) {
			// return cached
			if ('_m' in this) {
				return this._m;
			}
			// from eccentric anomaly
			// most expensive step
			var hE = this.E() / 2;
			// calculate the true anomaly
			return this._m = CYCLE(2 * Math.atan2(
				Math.sqrt(1+this._e) * Math.sin(hE),
				Math.sqrt(1-this._e) * Math.cos(hE)
			));
		}
		else {
			// calculate the true anomaly
			return CYCLE(2 * Math.atan2(
				Math.sqrt(1+this._e) * Math.sin(E/2),
				Math.sqrt(1-this._e) * Math.cos(E/2)
			));
		}
	}

	/*############################################################################*/
	// additional helper functions (expensive)
	// only use them if you really need too
	// no direct way from orbital elements yet
	/*############################################################################*/

	/******************************************************************************/
	// The radial velocity of an object with respect to a given point is the rate of
	// change of the distance between the object and the point. That is, the radial
	// velocity is the component of the object's velocity that points in the direction
	// of the radius connecting the object and the point. In astronomy, the point is
	// usually taken to be the observer on Earth, so the radial velocity then denotes
	// the speed with which the object moves away from or approaches the Earth.
	/******************************************************************************/
	// Klass.vt = function tangentialVelocity() {}
	/******************************************************************************/
	Klass.B = function radialVelocity()
	{
		// return cached value
		if ('_B' in this) return this._B;
		// calculate state vectors
		var r = this.r(), v = this.v();
		// get radial velocity from state vectors
		return this._B = r.dot(v) / r.length();
	};

	/******************************************************************************/
	// In celestial mechanics, the eccentricity vector of a Kepler orbit is the
	// dimensionless vector with direction pointing from apoapsis to periapsis and
	// with magnitude equal to the orbit's scalar eccentricity. For Kepler orbits
	// the eccentricity vector is a constant of motion. Its main use is in the
	// analysis of almost circular orbits, as perturbing (non-Keplerian) forces
	// on an actual orbit will cause the osculating eccentricity vector to change
	// continuously. For the eccentricity and argument of periapsis parameters,
	// eccentricity zero (circular orbit) corresponds to a singularity.
	/******************************************************************************/
	Klass.e3 = function eccentricity3()
	{
		// return cached value
		if ('_e3' in this) return this._e3;
		// force state vector calculation
		var r = this.r(), v = this.v();
		if (r !== null && v !== null) {
			return this._e3 = r.clone().multiplyScalar(
				v.lengthSq() - (this._G / r.length())
			).sub(
				v.clone().multiplyScalar(r.length() * this.B())
			).multiplyScalar(1 / this._G);
		}
	}

	/*############################################################################*/
	// getter functions for elements that are available after resolving
	/*############################################################################*/

	// Orbit inclination is the minimum angle between a reference plane and the
	// orbital plane or axis of direction of an object in orbit around another
	// object. The inclination is one of the six orbital parameters describing
	// the shape and orientation of a celestial orbit. It is the angular distance
	// of the orbital plane from the plane of reference (usually the primary's
	// equator or the ecliptic), normally stated in degrees. In the Solar System,
	// orbital inclination is usually stated with respect to Earth's orbit.
	Klass.i = function inclination() { return this._i; }

	// The orbital eccentricity of an astronomical object is a parameter that
	// determines the amount by which its orbit around another body deviates
	// from a perfect circle. A value of 0 is a circular orbit, values between
	// 0 and 1 form an elliptical orbit, 1 is a parabolic escape orbit, and
	// greater than 1 is a hyperbola. The term derives its name from the
	// parameters of conic sections, as every Kepler orbit is a conic section.
	// It is normally used for the isolated two-body problem, but extensions
	// exist for objects following a rosette orbit through the galaxy.
	Klass.e = function eccentricity() { return this._e; }

	// In geometry, the major axis of an ellipse is its longest diameter:
	// a line segment that runs through the center and both foci, with ends
	// at the widest points of the perimeter. The semi-major axis is on half
	// of the major axis, and thus runs from the centre, through a focus, and
	// to the perimeter. Essentially, it is the radius of an orbit at the
	// orbit's two most distant points. For the special case of a circle, the
	// semi-major axis is the radius. One can think of the semi-major axis as
	// an ellipse's long radius. The length of the semi-major axis a of an
	// ellipse is related to the semi-minor axis's length b through the
	// eccentricity e and the semilatus rectum ℓ.
	Klass.a = function semiMajorAxis() { return this._a; }
	Klass.b = function semiMinorAxis() { return this._b; }
	Klass.l = function semilatusRectum() { return this._l; }

	// The point of a body's elliptical orbit about the system's centre of mass where
	// the distance between the body and the centre of mass is at its maximum.
	// For some celestial bodies, specialised terms are used (aphelion/apogee).
	Klass.C = function apocenter() { return this._C; }
	// The point of a body's elliptical orbit about the system's centre of mass where
	// the distance between the body and the centre of mass is at its minimum.
	// For some celestial bodies, specialised terms are used (perihelion/perigee).
	Klass.c = function pericenter() { return this._c; }

	// Mean longitude is the ecliptic longitude at which an orbiting body
	// could be found if its orbit were circular and free of perturbations.
	// While nominally a simple longitude, in practice the mean longitude
	// is a hybrid angle.
	Klass.L = function meanLongitude() { return this._L; }

	// The longitude of the ascending node (☊ or Ω) is one of the orbital
	// elements used to specify the orbit of an object in space. It is the
	// angle from a reference direction, called the origin of longitude,
	// to the direction of the ascending node, measured in a reference plane.
	// The ascending node is the point where the orbit of the object passes
	// through the plane of reference.
	Klass.O = function ascendingNode() { return this._O; }

	// The argument of periapsis (also called argument of perifocus or
	// argument of pericenter), is one of the orbital elements (ω) of
	// an orbiting body. Parametrically, ω is the angle from the body's
	// ascending node to its periapsis, measured in the direction of motion.
	Klass.w = function argOfPeriapsis() { return this._w; }

	// The time of pericenter passage when the orbiting body passes through
	// the pericenter, closest to the central body. The mean anomaly is 0.0
	// when the orbiting body is at pericenter, so defining the orbital
	// elements at the epoch T (the time of the pericenter passage)
	// eliminates the need to determine the mean anomaly.
	Klass.T = function timeOfPericenter() { return this._T; }

	// In celestial mechanics, the longitude of the periapsis (ϖ) of
	// an orbiting body is the longitude (measured from the point of
	// the vernal equinox) at which the periapsis (closest approach
	// to the central body) would occur if the body's inclination were
	// zero. For motion of a planet around the Sun, this position could
	// be called longitude of perihelion. The longitude of periapsis is
	// a compound angle, with part of it being measured in the plane of
	// reference and the rest being measured in the plane of the orbit.
	// Likewise, any angle derived from the longitude of periapsis (e.g.
	// mean longitude and true longitude) will also be compound.
	Klass.W = function longitudeOfPeriapsis() { return this._W; }

	// In orbital mechanics, mean motion is the angular speed required
	// for a body to complete one orbit, assuming constant speed in a
	// circular orbit which completes in the same time as the variable
	// speed, elliptical orbit of the actual body.
	Klass.n = function meanMotion() { return this._n; }

	// In a closed system, no torque can be exerted on any matter
	// without the exertion on some other matter of an equal and
	// opposite torque. Hence, angular momentum can be exchanged
	// between objects in a closed system, but total angular momentum
	// before and after an exchange remains constant (is conserved)
	Klass.A = function angularMomentum() { return this._A; }

	// In celestial mechanics, the mean anomaly is an angle used in
	// calculating the position of a body in an elliptical orbit in the
	// classical two-body problem. It is the angular distance from the
	// pericenter which a fictitious body would have if it moved in a
	// circular orbit, with constant speed, in the same orbital period
	// as the actual body in its elliptical orbit. It is also the
	// product of mean motion and time since pericenter passage.
	Klass.M = function meanAnomaly() { return this._M; }

	// The orbital period is the time taken for a given object to make one
	// complete orbit around another object. When mentioned without further
	// qualification in astronomy this refers to the sidereal period of an
	// astronomical object, which is calculated with respect to the stars.
	Klass.P = function orbitalPeriod() { return this._P; }

	/*############################################################################*/
	// convert to vsop parameters (never seen them anywhere else)
	// those are calculated on demand, so you need to call me first
	/*############################################################################*/

	// q: sin(i/2)*cos(O) (vsop)
	Klass.q = function vsopPeriapsis()
	{
		// return cached calculation
		if ('_q' in this) return this._q;
		// calculation given in vsop87 example.f
		return this._q = Math.cos(this._O)
			* Math.sin(this._i / 2);
	};

	// p: sin(i/2)*sin(O) (vsop)
	Klass.p = function vsopApoapsis()
	{
		// return cached calculation
		if ('_p' in this) return this._p;
		// calculation given in vsop87 example.f
		return this._p = Math.sin(this._O)
			* Math.sin(this._i / 2);
	};

	// k: e*cos(W) (vsop)
	Klass.k = function vsopK()
	{
		// return cached calculation
		if ('_k' in this) return this._k;
		// calculation given in vsop87 example.f
		return this._k = this._e * Math.cos(this._W);
	};

	// h: e*sin(W) (vsop)
	Klass.h = function vsopH()
	{
		// return cached calculation
		if ('_h' in this) return this._h;
		// calculation given in vsop87 example.f
		return this._h = this._e * Math.sin(this._W);
	};

	/*############################################################################*/
	// calculate state vectors from orbital elements
	// TODO: implement for different time offsets (TBD)
	/*############################################################################*/

	// update orbital state for new epoch
	// advance position and reset some states
	// for dt = P, mean anomaly does not change
	Klass.update = function update(dt)
	{
		// check if elements are already resolved
		if (!this.elements) this.resolveElements(true);
		// advance mean anomaly for new time
		this._M = CYCLE(this._n * (dt - this._T));
		// adjust mean longitude for new time
		this._L = CYCLE(this._M + this._W);
		// reset dependent parameters
		delete this._E; delete this._m;
		// invalidate state vectors
		delete this._r; delete this._v;
		// chainable
		return this;
	}

	// orbital elements to spherical position (lon/lat/d)
	Klass.state = function spherical (dt)
	{
	}

	// orbital elements to rectangular position (x/y/z)
	Klass.state = function state (dt)
	{

		// check if elements are already resolved
		if (!this.elements) this.resolveElements(true);

		var e = this._e, a = this._a, i = this._i,
		    O = this._O, w = this._w, M = this._M,
		    E = this.E(), // eccentric anomaly
		    m = this.m(), // true anomaly
		    t = dt || 0; // time offset

		// Distance to true anomaly position
		var r = a * (1.0 - e * Math.cos(E));
		var vf = Math.sqrt(this._G * a) / r;

		// Perifocal reference plane
		var rx = r * Math.cos(m),
		    ry = r * Math.sin(m),
		    vx = vf * - Math.sin(E),
		    vy = vf * Math.sqrt(1.0 - e*e) * Math.cos(E);

		// Pre-calculate elements for rotation matrix
		var sinO = Math.sin(O), cosO = Math.cos(O),
		    sinI = Math.sin(i), cosI = Math.cos(i),
		    sinW = Math.sin(w), cosW = Math.cos(w),
		    sinWcosO = sinW*cosO, sinWsinO = sinW*sinO,
		    cosWcosO = cosW*cosO, cosWsinO = cosW*sinO,
		    FxX = (cosW*cosO - sinW*sinO*cosI),
		    FyX = (cosW*sinO + sinW*cosO*cosI),
		    FxY = (cosW*sinO*cosI + sinW*cosO),
		    FyY = (cosW*cosO*cosI - sinW*sinO),
		    FzX = (sinW*sinI),
		    FzY = (cosW*sinI);

		// Equatorial position
		var r = new Vector3(
			rx * FxX - ry * FxY,
			rx * FyX + ry * FyY,
			rx * FzX + ry * FzY
		);
		// Equatorial velocity
		var v = new Vector3(
			vx * FxX - vy * FxY,
			vx * FyX + vy * FyY,
			vx * FzX + vy * FzY
		);
		// cache results if no time offset
		if (!t) this._r = r, this._v = v;
		// return result object with reference
		// ToDo: maybe add position object
		// To calculate ra/dec and more stuff
		return { r: r, v: v, time: t, orbit: this };

	}
	// EO state

	/*############################################################################*/
	// getters for state vectors
	/*############################################################################*/

	// r: position state vector
	Klass.r = function position3()
	{
		// return cached
		if ('_r' in this) {
			return this._r;
		}
		// calculate at epoch time
		var state = this.state(0);
		// cache the result
		this._r = state.r;
		this._v = state.v;
		// return vector
		return state.r;
	}

	// v: velocity state vector
	Klass.v = function velocity3()
	{
		// return cached
		if ('_v' in this) {
			return this._v;
		}
		// calculate at epoch time
		var state = this.state(0);
		// cache the result
		this._r = state.r;
		this._v = state.v;
		// return vector
		return state.v;
	}

	/*############################################################################*/
	// add fully named getter functions if preferred
	/*############################################################################*/

	// orbital elements that are always calculated
	// these can be used as orbital input arguments
	Klass.inclination = Klass.i;
	Klass.eccentricity = Klass.e;
	Klass.semiMajorAxis = Klass.a;
	Klass.semiMinorAxis = Klass.b;
	Klass.semilatusRectum = Klass.l;
	Klass.meanLongitude = Klass.L;
	Klass.ascendingNode = Klass.O;
	Klass.argOfPericenter = Klass.w;
	Klass.timeOfPericenter = Klass.T;
	Klass.longitudeOfPericenter = Klass.W;
	Klass.meanMotion = Klass.n;
	Klass.meanAnomaly = Klass.M;
	Klass.orbitalPeriod = Klass.P;
	Klass.angularMomentum = Klass.A;

	// additional orbital elements only on demand
	// these must not be used as orbital input arguments
	Klass.trueAnomaly = Klass.m;
	Klass.radialVelocity = Klass.B;
	Klass.eccentricAnomaly = Klass.E;
	// additional parameters are calculated on demand
	Klass.apoapsis = Klass.C;
	Klass.aphelion = Klass.C;
	Klass.apocenter = Klass.C;
	Klass.periapsis = Klass.c;
	Klass.perhelion = Klass.c;
	Klass.pericenter = Klass.c;

	// state vectors at epoch time
	Klass.position = Klass.r;
	Klass.velocity = Klass.v;

	/*############################################################################*/
	// END OF AstroJS Orbit Module
	/*############################################################################*/

	exports.Orbit = exports.Orbital = Orbit;

})(this);
;
/*############################################################################*/
// AstroJS Time Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/
// Implementation is mostly one to one from libnova
// http://libnova.sourceforge.net/group__sidereal.html
// http://libnova.sourceforge.net/group__dynamical.html
// http://libnova.sourceforge.net/group__heliocentric.html
// http://libnova.sourceforge.net/group__nutation.html
/*############################################################################*/
'use strict';

(function (exports)
{

	/*############################################################################*/
	// constant factors for calculations
	/*############################################################################*/

	// dynamical time offset in seconds for
	// every second year from 1620 to 1992
	var delta_t = [
		124.0, 115.0, 106.0, 98.0, 91.0,
		85.0, 79.0, 74.0, 70.0, 65.0,
		62.0, 58.0, 55.0, 53.0, 50.0,
		48.0, 46.0, 44.0, 42.0, 40.0,
		37.0, 35.0, 33.0, 31.0, 28.0,
		26.0, 24.0, 22.0, 20.0, 18.0,
		16.0, 14.0, 13.0, 12.0, 11.0,
		10.0, 9.0, 9.0, 9.0, 9.0,
		9.0, 9.0, 9.0, 9.0, 10.0,
		10.0, 10.0, 10.0, 10.0, 11.0,
		11.0, 11.0, 11.0, 11.0, 11.0,
		11.0, 12.0, 12.0, 12.0, 12.0,
		12.0, 12.0, 13.0, 13.0, 13.0,
		13.0, 14.0, 14.0, 14.0, 15.0,
		15.0, 15.0, 15.0, 16.0, 16.0,
		16.0, 16.0, 16.0, 17.0, 17.0,
		17.0, 17.0, 17.0, 17.0, 17.0,
		17.0, 16.0, 16.0, 15.0, 14.0,
		13.7, 13.1, 12.7, 12.5, 12.5,
		12.5, 12.5, 12.5, 12.5, 12.3,
		12.0, 11.4, 10.6, 9.6, 8.6,
		7.5, 6.6, 6.0, 5.7, 5.6,
		5.7, 5.9, 6.2, 6.5, 6.8,
		7.1, 7.3, 7.5, 7.7, 7.8,
		7.9, 7.5, 6.4, 5.4, 2.9,
		1.6, -1.0, -2.7, -3.6, -4.7,
		-5.4, -5.2, -5.5, -5.6, -5.8,
		-5.9, -6.2, -6.4, -6.1, -4.7,
		-2.7, 0.0, 2.6, 5.4, 7.7,
		10.5, 13.4, 16.0, 18.2, 20.2,
		21.2, 22.4, 23.5, 23.9, 24.3,
		24.0, 23.9, 23.9, 23.7, 24.0,
		24.3, 25.3, 26.2, 27.3, 28.2,
		29.1, 30.0, 30.7, 31.4, 32.2,
		33.1, 34.0, 35.0, 36.5, 38.3,
		40.2, 42.2, 44.5, 46.5, 48.5,
		50.5, 52.2, 53.8, 54.9, 55.8,
		56.9, 58.3
	];

	// arguments and coefficients taken from table 21A on page 133
	var nut_args = [
		[ 0.0,  0.0,  0.0,  0.0,  1.0], [-2.0,  0.0,  0.0,  2.0,  2.0], [ 0.0,  0.0,  0.0,  2.0,  2.0],
		[ 0.0,  0.0,  0.0,  0.0,  2.0], [ 0.0,  1.0,  0.0,  0.0,  0.0], [ 0.0,  0.0,  1.0,  0.0,  0.0],
		[-2.0,  1.0,  0.0,  2.0,  2.0], [ 0.0,  0.0,  0.0,  2.0,  1.0], [ 0.0,  0.0,  1.0,  2.0,  2.0],
		[-2.0, -1.0,  0.0,  2.0,  2.0], [-2.0,  0.0,  1.0,  0.0,  0.0], [-2.0,  0.0,  0.0,  2.0,  1.0],
		[ 0.0,  0.0, -1.0,  2.0,  2.0], [ 2.0,  0.0,  0.0,  0.0,  0.0], [ 0.0,  0.0,  1.0,  0.0,  1.0],
		[ 2.0,  0.0, -1.0,  2.0,  2.0], [ 0.0,  0.0, -1.0,  0.0,  1.0], [ 0.0,  0.0,  1.0,  2.0,  1.0],
		[-2.0,  0.0,  2.0,  0.0,  0.0], [ 0.0,  0.0, -2.0,  2.0,  1.0], [ 2.0,  0.0,  0.0,  2.0,  2.0],
		[ 0.0,  0.0,  2.0,  2.0,  2.0], [ 0.0,  0.0,  2.0,  0.0,  0.0], [-2.0,  0.0,  1.0,  2.0,  2.0],
		[ 0.0,  0.0,  0.0,  2.0,  0.0], [-2.0,  0.0,  0.0,  2.0,  0.0], [ 0.0,  0.0, -1.0,  2.0,  1.0],
		[ 0.0,  2.0,  0.0,  0.0,  0.0], [ 2.0,  0.0, -1.0,  0.0,  1.0], [-2.0,  2.0,  0.0,  2.0,  2.0],
		[ 0.0,  1.0,  0.0,  0.0,  1.0], [-2.0,  0.0,  1.0,  0.0,  1.0], [ 0.0, -1.0,  0.0,  0.0,  1.0],
		[ 0.0,  0.0,  2.0, -2.0,  0.0], [ 2.0,  0.0, -1.0,  2.0,  1.0], [ 2.0,  0.0,  1.0,  2.0,  2.0],
		[ 0.0,  1.0,  0.0,  2.0,  2.0], [-2.0,  1.0,  1.0,  0.0,  0.0], [ 0.0, -1.0,  0.0,  2.0,  2.0],
		[ 2.0,  0.0,  0.0,  2.0,  1.0], [ 2.0,  0.0,  1.0,  0.0,  0.0], [-2.0,  0.0,  2.0,  2.0,  2.0],
		[-2.0,  0.0,  1.0,  2.0,  1.0], [ 2.0,  0.0, -2.0,  0.0,  1.0], [ 2.0,  0.0,  0.0,  0.0,  1.0],
		[ 0.0, -1.0,  1.0,  0.0,  0.0], [-2.0, -1.0,  0.0,  2.0,  1.0], [-2.0,  0.0,  0.0,  0.0,  1.0],
		[ 0.0,  0.0,  2.0,  2.0,  1.0], [-2.0,  0.0,  2.0,  0.0,  1.0], [-2.0,  1.0,  0.0,  2.0,  1.0],
		[ 0.0,  0.0,  1.0, -2.0,  0.0], [-1.0,  0.0,  1.0,  0.0,  0.0], [-2.0,  1.0,  0.0,  0.0,  0.0],
		[ 1.0,  0.0,  0.0,  0.0,  0.0], [ 0.0,  0.0,  1.0,  2.0,  0.0], [ 0.0,  0.0, -2.0,  2.0,  2.0],
		[-1.0, -1.0,  1.0,  0.0,  0.0], [ 0.0,  1.0,  1.0,  0.0,  0.0], [ 0.0, -1.0,  1.0,  2.0,  2.0],
		[ 2.0, -1.0, -1.0,  2.0,  2.0], [ 0.0,  0.0,  3.0,  2.0,  2.0], [ 2.0, -1.0,  0.0,  2.0,  2.0]
	];
	var nut_coeffs = [
		[-171996.0, -174.2, 92025.0,8.9], [-13187.0, -1.6, 5736.0, -3.1], [-2274.0, -0.2, 977.0, -0.5],
		[2062.0,   0.2,-895.0,  0.5], [1426.0,  -3.4,  54.0,  -0.1], [ 712.0,   0.1,  -7.0,   0.0],
		[-517.0,   1.2, 224.0, -0.6], [-386.0,  -0.4, 200.0,   0.0], [-301.0,   0.0, 129.0,  -0.1],
		[ 217.0, - 0.5, -95.0,  0.3], [-158.0,   0.0,   0.0,   0.0], [ 129.0,   0.1, -70.0,   0.0],
		[ 123.0,   0.0, -53.0,  0.0], [  63.0,   0.0,   0.0,   0.0], [  63.0,   0.1, -33.0,   0.0],
		[ -59.0,   0.0,  26.0,  0.0], [ -58.0,  -0.1,  32.0,   0.0], [ -51.0,   0.0,  27.0,   0.0],
		[  48.0,   0.0,   0.0,  0.0], [  46.0,   0.0, -24.0,   0.0], [ -38.0,   0.0,  16.0,   0.0],
		[ -31.0,   0.0,  13.0,  0.0], [  29.0,   0.0,   0.0,   0.0], [  29.0,   0.0, -12.0,   0.0],
		[  26.0,   0.0,   0.0,  0.0], [ -22.0,   0.0,   0.0,   0.0], [  21.0,   0.0, -10.0,   0.0],
		[  17.0, - 0.1,   0.0,  0.0], [  16.0,   0.0,  -8.0,   0.0], [ -16.0,   0.1,   7.0,   0.0],
		[ -15.0,   0.0,   9.0,  0.0], [ -13.0,   0.0,   7.0,   0.0], [ -12.0,   0.0,   6.0,   0.0],
		[  11.0,   0.0,   0.0,  0.0], [ -10.0,   0.0,   5.0,   0.0], [  -8.0,   0.0,   3.0,   0.0],
		[   7.0,   0.0,  -3.0,  0.0], [  -7.0,   0.0,   0.0,   0.0], [  -7.0,   0.0,   3.0,   0.0],
		[  -7.0,   0.0,   3.0,  0.0], [   6.0,   0.0,   0.0,   0.0], [   6.0,   0.0,  -3.0,   0.0],
		[   6.0,   0.0,  -3.0,  0.0], [  -6.0,   0.0,   3.0,   0.0], [  -6.0,   0.0,   3.0,   0.0],
		[   5.0,   0.0,   0.0,  0.0], [  -5.0,   0.0,   3.0,   0.0], [  -5.0,   0.0,   3.0,   0.0],
		[  -5.0,   0.0,   3.0,  0.0], [   4.0,   0.0,   0.0,   0.0], [   4.0,   0.0,   0.0,   0.0],
		[   4.0,   0.0,   0.0,  0.0], [  -4.0,   0.0,   0.0,   0.0], [  -4.0,   0.0,   0.0,   0.0],
		[  -4.0,   0.0,   0.0,  0.0], [   3.0,   0.0,   0.0,   0.0], [  -3.0,   0.0,   0.0,   0.0],
		[  -3.0,   0.0,   0.0,  0.0], [  -3.0,   0.0,   0.0,   0.0], [  -3.0,   0.0,   0.0,   0.0],
		[  -3.0,   0.0,   0.0,  0.0], [  -3.0,   0.0,   0.0,   0.0], [  -3.0,   0.0,   0.0,   0.0]
	];

	/*############################################################################*/
	// return nutation parameters on given julian days
	/*############################################################################*/

	var FD0 = 297.85036 * DEG2RAD, FD1 = 445267.111480 * DEG2RAD, FD2 = - 0.0019142 * DEG2RAD, FD3 = DEG2RAD / 189474.0,
	    FM0 = 357.52772 * DEG2RAD, FM1 = 35999.050340 * DEG2RAD, FM2 = - 0.0086972 * DEG2RAD, FM3 = - DEG2RAD / 300000.0,
	    FMM0 = 134.96298 * DEG2RAD, FMM1 = 477198.867398 * DEG2RAD, FMM2 = 0.0086972 * DEG2RAD, FMM3 = DEG2RAD / 56250.0,
	    FF0 = 93.2719100 * DEG2RAD, FF1 = 483202.017538 * DEG2RAD, FF2 = - 0.0036825 * DEG2RAD, FF3 = DEG2RAD / 327270.0,
	    FO0 = 125.04452 * DEG2RAD, FO1 = - 1934.136261 * DEG2RAD, FO2 = 0.0020708 * DEG2RAD, FO3 = DEG2RAD / 450000.0;

	function getNutation(JD)
	{

		// should we bother recalculating nutation (caching)
		// if (fabs(JD - c_JD) > EPOCH_THRESHOLD) {
		// set the new epoch //
		// c_JD = JD;

		// get julian ephemeris day
		var JDE = JD2JDE(JD);

		// calc T and dependants
		var T = JD2J2K(JDE) / 100,
		    T2 = T * T, T3 = T2 * T;

		// calculate D,M,M',F and Omega (convert to radians)
		var D = FD0 + FD1 * T + FD2 * T2 + FD3 * T3;
		var M = FM0 + FM1 * T + FM2 * T2 + FM3 * T3;
		var MM = FMM0 + FMM1 * T + FMM2 * T2 + FMM3 * T3;
		var F = FF0 + FF1 * T + FF2 * T2 + FF3 * T3;
		var O = FO0 + FO1 * T + FO2 * T2 + FO3 * T3;

		// init variables for coeff sums
		// get accumulated in for loop
		var c_longitude = 0, c_obliquity = 0;
		var coeff_sine, coeff_cos, arg;

		// calc sum of terms in table 21A
		for (var i = 0; i < nut_coeffs.length; i++) {
			// calc coefficients of sine and cosine
			coeff_sine = (nut_coeffs[i][0] +
				(nut_coeffs[i][1] * T));
			coeff_cos = (nut_coeffs[i][2] +
				(nut_coeffs[i][3] * T));
			// calculate main argument
			arg = nut_args[i][0] * D
			    + nut_args[i][1] * M
			    + nut_args[i][2] * MM
			    + nut_args[i][3] * F
			    + nut_args[i][4] * O;
			// sum up oscillating elements
			c_longitude += coeff_sine * Math.sin(arg);
			c_obliquity += coeff_cos * Math.cos(arg);
		}

		// c_longitude /= 100000.0;
		// c_obliquity /= 100000.0;

		// calculate mean ecliptic - Meeus 2nd edition, eq. 22.2
		var c_ecliptic = 23.0 + 26.0 / 60.0 + 21.448 / 3600.0
		               - 46.81500 / 3600.0 * T
		               - 0.000590 / 3600.0 * T2
		               + 0.001813 / 3600.0 * T3;

		// change to radiants
		c_ecliptic *= DEG2RAD;
		// use special conversion factor
		// change time (hours?) to to arcsecs
		c_longitude /= 3600 * 100 * 100 / DEG2RAD;
		c_obliquity /= 3600 * 100 * 100 / DEG2RAD;

		// Uncomment this if function should return
		// true obliquity rather than mean obliquity
		/* c_ecliptic += c_obliquity; */

		// } // caching

		// return results
		return {
			longitude: TURN(c_longitude), // verified
			obliquity: TURN(c_obliquity), // verified
			ecliptic: CYCLE(c_ecliptic) // unverified
		}

	}
	// EO nutation

	// Stephenson and Houlden for years prior to 948 A.D.
	function getDynamicalTimeDiffSH1(JD)
	{
		// number of centuries from 948
		var E = (JD - 2067314.5) / 36525.0;
		return 1830.0 - 405.0 * E + 46.5 * E * E;
	}

	// Stephenson and Houlden for years between 948 A.D. and 1600 A.D.
	function getDynamicalTimeDiffSH2(JD)
	{
		/* number of centuries from 1850 */
		var t = (JD - 2396758.5) / 36525.0;
		return 22.5 * t * t;
	}

	// Table 9.a pg 72 for years 1600..1992
	// uses interpolation formula 3.3 on pg 25
	function getDynamicalTimeDiffTable(JD)
	{
		// get no days since 1620 and divide by 2 years
		var i = Math.floor((JD - 2312752.5) / 730.5);
		// get the base interpolation factor in the table
		if (i > (delta_t.length - 2)) i = delta_t.length - 2;
		// calculate a, b, c, n
		var a = delta_t[i+1] - delta_t[i], b = delta_t[i+2] - delta_t[i+1],
		    c = a - b, n = ((JD - (2312752.5 + (730.5 * i))) / 730.5);
		return delta_t[i + 1] + n / 2 * (a + b + n * c);
	}

	// get the dynamical time diff in the near past / future 1992 .. 2010
	/// uses interpolation formula 3.3 on pg 25
	function getDynamicalTimeDiffNear(JD)
	{
		// TD for 1990, 2000, 2010
		var delta_T = [ 56.86, 63.83, 70.0 ];
		// calculate TD by interpolating value
		var a = delta_T[1] - delta_T[0],
		    b = delta_T[2] - delta_T[1],
		    c = b - a;
		// get number of days since 2000 and divide by 10 years
		var n = (JD - 2451544.5) / 3652.5;
		return delta_T[1] + (n / 2) * (a + b + n * c);
	}

	// uses equation 9.1 pg 73 to calc JDE for other JD values
	function getDynamicalTimeDiffElse(JD)
	{
		var a = (JD - 2382148.0);
		return -15.0 + a * a / 41048480.0;
	}

	// Calculates the dynamical time (TD) difference in seconds
	// (delta T) from universal time. Equation 9.1 on pg 73.
	// check when JD is, and use corresponding formula
	function getDynamicalTimeDiff(JD)
	{
		// check for date < 948 A.D.
		if (JD < 2067314.5) {
			// Stephenson and Houlden
			return getDynamicalTimeDiffSH1(JD);
		}
		// check for date 948..1600 A.D.
		else if (JD >= 2067314.5 && JD < 2305447.5) {
			// Stephenson and Houlden
			return getDynamicalTimeDiffSH2(JD);
		}
		// check for value in table 1620..1992
		else if (JD >= 2312752.5 && JD < 2448622.5) {
			// interpolation of table
			return getDynamicalTimeDiffTable(JD);
		}
		// check for near future 1992..2010
		else if (JD >= 2448622.5 && JD <= 2455197.5) {
			// use value interpolation
			return getDynamicalTimeDiffNear(JD);
		}
		// other time period (outside)
		return getDynamicalTimeDiffElse(JD);
	}

	// Calculates the Julian Ephemeris Day(JDE)
	function JD2JDE(JD)
	{
		// from the given Julian Day (JD)
		return JD + getDynamicalTimeDiff(JD) / DAY2SEC;
	}

	// Calculates the Julian Day(JDE)
	function JDE2JD(JDE)
	{
		// from the given Julian Ephemeris Day (JD)
		return JDE - getDynamicalTimeDiff(JDE) / DAY2SEC;
	}

	/*############################################################################*/
	// Sidereal time calculations
	/*############################################################################*/

	// factors for sidereal time offset
	var FST1 = 280.46061837 * DEG2RAD,
	    FST2 = 360.98564736629 * DEG2RAD,
	    FST3 = 0.000387933 * DEG2RAD,
	    FST4 = - DEG2RAD / 38710000.0,
	    // ratio longitude nutation
	    FLON = 15.0 * DEG2HMS;

	// returns rad (you want HMS?)
	function getMeanSiderealTime(JD)
	{
		var T = JD2J2K(JD) / 100;
		// calculate mean angle (in radians)
		var sidereal = FST1 + FST2 *(JD - 2451545.0)
			           + FST3 * T * T + FST4 * T * T * T;
		// clamp to valid range
		return CYCLE(sidereal);
	}

	// returns rad (you want HMS?)
	function getApparentSiderealTime(JD)
	{
		// get nutation parameters
		var nutation = getNutation(JD);
		// get the mean sidereal time and add
		return getMeanSiderealTime(JD) +
			// add corrections for nutation in longitude
			// and for the true obliquity o the ecliptic
			nutation.longitude / FLON *
			Math.cos(nutation.obliquity);
	}

	/*############################################################################*/
	// END OF AstroJS Time Module
	/*############################################################################*/

	// date converter
	exports.JD2JDE = JD2JDE;
	exports.JDE2JD = JDE2JD;

	// sidereal time calculations
	exports.getMeanSiderealTime = getMeanSiderealTime;
	exports.getApparentSiderealTime = getApparentSiderealTime;

	// calculate earth nutations
	exports.getNutation = getNutation;

})(this);
;
/*############################################################################*/
// AstroJS Coordinate Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/
// https://en.wikipedia.org/wiki/Cartesian_coordinate_system (xyz)
// https://en.wikipedia.org/wiki/Spherical_coordinate_system (lbr)
// https://en.wikipedia.org/wiki/Cylindrical_coordinate_system (zlp)
/*############################################################################*/
'use strict';

(function (exports) {

	/*############################################################################*/
	// private converter and helper functions
	/*############################################################################*/

	// getter functions for calculated coordinates
	function cyl() { return { p: this.p, l: this.l, z: this.z }; }
	function cart() { return { x: this.x, y: this.y, z: this.z }; }
	function sph() { return { l: this.l, b: this.b, i: this.i, r: this.r }; }

	/*############################################################################*/
	// These functions act as auto-loaders. They will convert the
	// coordinates once and then replace the getter function.
	/*############################################################################*/

	// Cartesian to Spherical
	function cart2sph()
	{
		this.r = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
		this.i = Math.acos(this.z / this.r), this.b = PI/2 - this.i;
		this.l = Math.atan2(this.y, this.x);
		return (this.sph = sph).call(this);
	}

	// Spherical to Cartesian
	function sph2cart()
	{
		var rsb = this.r * Math.sin(this.i);
		this.x = rsb * Math.cos(this.l);
		this.y = rsb * Math.sin(this.l);
		this.z = this.r * Math.cos(this.i);
		return (this.cart = cart).call(this);
	}

	// Cartesian to Cylindrical
	function cart2cyl()
	{
		this.p = Math.sqrt(this.x*this.x + this.y*this.y);
		this.l = Math.atan2(this.y, this.x);
		return (this.cyl = cyl).call(this);
	}

	// Cylindrical to Cartesian
	function cyl2cart()
	{
		this.x = this.p * Math.cos(this.l);
		this.y = this.p * Math.sin(this.l);
		return (this.cart = cart).call(this);
	}

	// Cylindrical to Spherical
	function cyl2sph()
	{
		this.i = Math.atan2(this.p, this.z), this.b = PI/2 - this.i;
		this.r = Math.sqrt(this.p*this.p + this.z*this.z);
		return (this.sph = sph).call(this);
	}

	// Spherical to Cylindrical
	function sph2cyl()
	{
		this.p = this.r * Math.cos(this.b);
		this.z = this.r * Math.sin(this.b);
		return (this.cyl = cyl).call(this);
	}

	/*############################################################################*/
	// Class Constructor for Coordinate
	/*############################################################################*/

	/******************************************************************************/
	// Coordinate supports conversion between Cartesian, Spherical
	// and Cylindrical Coordinates. Use either for the constructor.
	/******************************************************************************/
	function Coord(state)
	{
		// from Cartesian coordinates
		if ('x' in state && 'y' in state && 'z' in state) {
			this.x = state.x, this.y = state.y, this.z = state.z;
			this.cart = cart, this.sph = cart2sph, this.cyl = cart2cyl;
		}
		// from Cylindrical coordinates
		else if ('p' in state && 'l' in state && 'z' in state) {
			this.p = state.p, this.l = state.l, this.z = state.z;
			this.cart = cyl2cart, this.sph = cyl2sph, this.cyl = cyl;
		}
		// from Spherical coordinates
		else if ('l' in state && 'r' in state) {
			// store given parameters, then ...
			this.l = state.l, this.r = state.r;
			// ... inclination or elevation
			if ('i' in state || 'b' in state) {
				this.cart = sph2cart, this.sph = sph, this.cyl = sph2cyl;
				if ('b' in state) this.b = state.b, this.i = PI/2 - this.b;
				else if ('i' in state) this.i = state.i, this.b = PI/2 - this.i;
			}
		}
	}

	/*############################################################################*/
	// conversion between various formats
	/*############################################################################*/
	// Equatorial - declination (d) and hour angle (h)
	//            - declination (d) and right ascension (a)
	// Ecliptic - ecliptic latitude (ß) and ecliptic longitude (?)
	// Galactic - galactic latitude (b) and galactic longitude (l)
	// Observer - altitude (a) or elevation and azimuth (A)
	// Note: VSOP87 coordinates are heliocentric ecliptic
	/*############################################################################*/
	// ecliptic to equatorial (compensate axial tilt)
	// equatorial to galactic (compensate precession)
	/*############################################################################*/
	// Mean equinox of date: Equator rotated by precession to its position
	// at "date", but free from the small periodic oscillations of nutation
	// True equinox of date: This is the actual intersection of the two
	// planes at any particular moment, with all motions accounted for.
	/*############################################################################*/

	// ecliptic to equatorial coordinates
	// pass obliquity of ecliptic (axial tilt)
	Coord.prototype.ecl2equ = function ecl2equ(tilt)
	{
		// convert via Cartesian
		var cart = this.cart(),
		    sin_e = Math.sin(tilt),
		    cos_e = Math.cos(tilt);
		// return new coordinate
		return new Coord({
			x: cart.x,
			y: cart.y * cos_e - cart.z * sin_e,
			z: cart.z * cos_e + cart.y * sin_e,
		});
	}

	// equatorial to ecliptic coordinates
	// pass obliquity of ecliptic (axial tilt)
	Coord.prototype.equ2ecl = function equ2ecl(tilt)
	{
		// convert via Cartesian
		var cart = this.cart(),
		    sin_e = Math.sin(tilt),
		    cos_e = Math.cos(tilt);
		// return new coordinate
		return new Coord({
			x: cart.x,
			y: cart.y * cos_e + cart.z * sin_e,
			z: cart.z * cos_e - cart.y * sin_e,
		});
	}

	var posangle = 32.932 * DEG2RAD;
	var pole_ra = 192.859508 * DEG2RAD;
	var pole_dec = 27.128336 * DEG2RAD;

	// North galactic pole (B1950)
	// var pole_ra = 192.25 * DEG2RAD;
	// var pole_dec = 27.4 * DEG2RAD;
	// var posangle = 33.0 * DEG2RAD;

	// galactic to equatorial coordinates
	// equatorial coordinate has only l/b
	Coord.prototype.gal2equ = function gal2equ()
	{
		// pre-calculations
		var sph = this.sph(),
		    l = sph.l, b = sph.b,
		    sin_b = Math.sin(b),
		    cos_b = Math.cos(b),
		    sin_pdc = Math.sin(pole_dec),
		    cos_pdc = Math.cos(pole_dec),
		    sin_pos = Math.sin(l - posangle),
		    cos_pos = Math.cos(l - posangle),
		    sincos_bp = cos_b * sin_pos;
		// ToDo: compensate for precision if epoch differs
		// to galactic coordinates after precession compensated
		var B = Math.asin( sin_b * sin_pdc + sincos_bp * cos_pdc );
		var L = Math.atan2(cos_b * cos_pos, sin_b * cos_pdc - sincos_bp * sin_pdc);
		// return object in valid range
		// ToDo: should `b` be half turn?
		return { l: CYCLE(L + pole_ra), b: TURN(B) };
	}

	// equatorial to galactic coordinates
	// gallactic coordinate has only l/b
	Coord.prototype.equ2gal = function equ2gal()
	{
		// pre-calculations
		var sph = this.sph(),
		    l = sph.l, b = sph.b,
		    sin_b = Math.sin(b),
		    cos_b = Math.cos(b),
		    tan_b = sin_b / cos_b,
		    sin_pdc = Math.sin(pole_dec),
		    cos_pdc = Math.cos(pole_dec),
		    sin_pos = Math.sin(pole_ra - l),
		    cos_pos = Math.cos(pole_ra - l),
		    sincos_bp = cos_b * sin_pos;
		// ToDo: compensate for precision if epoch differs
		// to equatorial coordinates after precession compensated
		var B = Math.asin( sin_b * sin_pdc + cos_b * cos_pdc * cos_pos );
		var L = Math.atan2( sin_pos, cos_pos * sin_pdc - tan_b * cos_pdc);
		// return object in valid range
		// ToDo: should `b` be half turn?
		return { l: CYCLE(posangle - L - PI/2), b: TURN(B) };
	}

	/*############################################################################*/
	// Precession to convert from the international terrestrial reference
	// system (ITRF) to the international celestial reference frame (ICRF)
	/*############################################################################*/

	// precession factors for J2000 frame
	var PFA = 2306.2181*DEG2RAD, PFB = 1.39656*DEG2RAD, PFC = 0.000139*DEG2RAD,
	    PFD = 0.30188*DEG2RAD, PFE = 0.000344*DEG2RAD, PFF = 0.017998*DEG2RAD,
	    PFG = 1.09468*DEG2RAD, PFH = 0.000066*DEG2RAD, PFI = 0.018203*DEG2RAD,
	    PFJ = 2004.3109*DEG2RAD, PFK = 0.85330*DEG2RAD, PFL = 0.000217*DEG2RAD,
	    PFM = 0.42665*DEG2RAD, PFN = 0.000217*DEG2RAD, PFP = 0.041833*DEG2RAD;

	Coord.prototype.precess = function precess(JD, epoch)
	{
		// Change original ra and dec to radians
		var mean_ra = this.l, mean_dec = this.b;
		// calc t, zeta, eta and theta for J2000.0 Equ 20.3
		var eta, zeta, theta, T, T2,
		    t = (JD - epoch) / 360000.0,
		    t2 = t * t, t3 = t2 *t;
		// optimize for epoch == 0
		if (t) {
			T = epoch / 360000.0, T2 = T * T;
			eta = (PFA + PFB * T - PFC * T2) * t
			     + (PFG + PFH * T) * t2 + PFI * t3;
			zeta = (PFA + PFB * T - PFC * T2) * t
			     + (PFD - PFE * T) * t2 + PFF * t3;
			theta = (PFJ - PFK * T - PFN * T2) * t
				    - (PFM + PFN * T) * t2 - PFP * t3;
		}
		else {
			eta = PFA * t + PFG * t2 + PFP * t3;
			zeta = PFA * t + PFD * t2 + PFF * t3;
			theta = PFJ * t - PFN * t2 - PFP * t3;
		}

		// calc A,B,C equ 20.4
		var sin_md = Math.sin(mean_dec), cos_md = Math.cos(mean_dec),
		    mean_term = cos_md * Math.cos(mean_ra + zeta),
		    A = cos_md * Math.sin(mean_ra + zeta),
		    B = Math.cos(theta) * mean_term - Math.sin(theta) * Math.sin(mean_dec),
		    C = Math.sin (theta) * mean_term + Math.cos(theta) * Math.sin(mean_dec);

		// calculate right ascension
		var ra = Math.atan2(A, B) + eta, dec;

		// check for object near celestial pole
		if (mean_dec > (0.4 * PI) || mean_dec < (-0.4 * PI)) {
			// close to pole (better precision)
			dec = Math.acos(sqrt(A * A + B * B));
			// check 0 <= acos() <= PI
			if (mean_dec < 0.) { dec *= -1;  }
		}
		// not close to pole
		else { dec = Math.asin(C); }

		// return object in valid range
		// ToDo: should `b` be half turn?
		return { l: CYCLE(ra), b: TURN(dec) };
	}

	/*############################################################################*/
	// END OF AstroJS Coordinate Module
	/*############################################################################*/

	exports.Coord = Coord;

})(this);
;
})(window)
/* crc: 1F428CBB56B4B0C614B4867F245CC4B0 */

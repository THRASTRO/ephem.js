/* autogenerated by webmerge (join context) */
;
/*
Astronomical Calculations (https://github.com/mgreter/astro.js)
- Copyright (c) 2017 Marcel Greter (http://github.com/mgreter)
*/;
/* Vector3 implementation included */;
(function(window) {;
// THREE.js Math "Polyfill"

(function() {

	// exit early
	if (this.THREE) {
		return;
	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function generateUUID() {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

						uuid[ i ] = '-';

					} else if ( i === 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}

				}

				return uuid.join( '' );

			};

		}(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		nearestPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

		},

		nextPowerOfTwo: function ( value ) {

			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;

			return value;

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	function Euler( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;
	
	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	Euler.DefaultOrder = 'XYZ';

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix = new Matrix4();

			return function project( camera ) {

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		unproject: function () {

			var matrix = new Matrix4();

			return function unproject( camera ) {

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		distanceToManhattan: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			var sinPhiRadius = Math.sin( s.phi ) * s.radius;

			this.x = sinPhiRadius * Math.sin( s.theta );
			this.y = Math.cos( s.phi ) * s.radius;
			this.z = sinPhiRadius * Math.cos( s.theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			this.x = c.radius * Math.sin( c.theta );
			this.y = c.y;
			this.z = c.radius * Math.cos( c.theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	Object.assign( Matrix3.prototype, {
	
		isMatrix3: true,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
	
			return this;
	
		},
	
		setFromMatrix4: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 4 ], me[  8 ],
				me[ 1 ], me[ 5 ], me[  9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]
	
			);
	
			return this;
	
		},
	
		applyToBufferAttribute: function () {
	
			var v1 = new Vector3();
	
			return function applyToBufferAttribute( attribute ) {
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );
	
					v1.applyMatrix3( this );
	
					attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
				}
	
				return attribute;
	
			};
	
		}(),
	
		multiply: function ( m ) {
	
			return this.multiplyMatrices( this, m );
	
		},
	
		premultiply: function ( m ) {
	
			return this.multiplyMatrices( m, this );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];
	
			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnDegenerate ) {
	
			if ( matrix && matrix.isMatrix4 ) {
	
				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );
	
			}
	
			var me = matrix.elements,
				te = this.elements,
	
				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,
	
				det = n11 * t11 + n21 * t12 + n31 * t13;
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate === true ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				return this.identity();
	
			}
	
			var detInv = 1 / det;
	
			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		getNormalMatrix: function ( matrix4 ) {
	
			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 9; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			for ( var i = 0; i < 9; i ++ ) {
	
				this.elements[ i ] = array[ i + offset ];
	
			}
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];
	
			return array;
	
		}
	
	} );
	
	Object.assign( Matrix4.prototype, {
	
		isMatrix4: true,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new Matrix4().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
	
			return this;
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements, me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	
			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );
	
			return this;
	
		},
	
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1 = new Vector3();
	
			return function extractRotation( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( ! ( euler && euler.isEuler ) ) {
	
				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q._x, y = q._y, z = q._z, w = q._w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;
	
			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;
	
			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		lookAt: function () {
	
			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();
	
			return function lookAt( eye, target, up ) {
	
				var te = this.elements;
	
				z.subVectors( eye, target );
	
				if ( z.lengthSq() === 0 ) {
	
					// eye and target are in the same position
	
					z.z = 1;
	
				}
	
				z.normalize();
				x.crossVectors( up, z );
	
				if ( x.lengthSq() === 0 ) {
	
					// up and z are parallel
	
					if ( Math.abs( up.z ) === 1 ) {
	
						z.x += 0.0001;
	
					} else {
	
						z.z += 0.0001;
	
					}
	
					z.normalize();
					x.crossVectors( up, z );
	
				}
	
				x.normalize();
				y.crossVectors( z, x );
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		premultiply: function ( m ) {
	
			return this.multiplyMatrices( m, this );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		applyToBufferAttribute: function () {
	
			var v1 = new Vector3();
	
			return function applyToBufferAttribute( attribute ) {
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );
	
					v1.applyMatrix4( this );
	
					attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
				}
	
				return attribute;
	
			};
	
		}(),
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnDegenerate ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,
	
				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate === true ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				return this.identity();
	
			}
	
			var detInv = 1 / det;
	
			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
			return this;
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeShear: function ( x, y, z ) {
	
			this.set(
	
				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector = new Vector3();
			var matrix = new Matrix4();
	
			return function decompose( position, quaternion, scale ) {
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
				matrix.copy( this );
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makePerspective: function ( left, right, top, bottom, near, far ) {
	
			if ( far === undefined ) {
	
				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
	
			}
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );
	
			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;
	
			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				this.elements[ i ] = array[ i + offset ];
	
			}
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		}
	
	} );

	Object.assign( Quaternion, {
	
		slerp: function ( qa, qb, qm, t ) {
	
			return qm.copy( qa ).slerp( qb, t );
	
		},
	
		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
			// fuzz-free, array-based Quaternion SLERP operation
	
			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],
	
				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];
	
			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
				var s = 1 - t,
	
					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;
	
				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {
	
					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );
	
					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;
	
				}
	
				var tDir = t * dir;
	
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
	
				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {
	
					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
	
				}
	
			}
	
			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
	
		}
	
	} );
	
	Object.defineProperties( Quaternion.prototype, {
	
		x: {
	
			get: function () {
	
				return this._x;
	
			},
	
			set: function ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			}
	
		},
	
		y: {
	
			get: function () {
	
				return this._y;
	
			},
	
			set: function ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			}
	
		},
	
		z: {
	
			get: function () {
	
				return this._z;
	
			},
	
			set: function ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			}
	
		},
	
		w: {
	
			get: function () {
	
				return this._w;
	
			},
	
			set: function ( value ) {
	
				this._w = value;
				this.onChangeCallback();
	
			}
	
		}
	
	} );
	
	Object.assign( Quaternion.prototype, {
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._w );
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( ! ( euler && euler.isEuler ) ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var cos = Math.cos;
			var sin = Math.sin;
	
			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );
	
			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );
	
			if ( order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1 = new Vector3();
			var r;
	
			var EPS = 0.000001;
	
			return function setFromUnitVectors( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				return this.normalize();
	
			};
	
		}(),
	
		inverse: function () {
	
			return this.conjugate().normalize();
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		premultiply: function ( q ) {
	
			return this.multiplyQuaternions( q, this );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	} );

	Object.defineProperties( Euler.prototype, {
	
		x: {
	
			get: function () {
	
				return this._x;
	
			},
	
			set: function ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			}
	
		},
	
		y: {
	
			get: function () {
	
				return this._y;
	
			},
	
			set: function ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			}
	
		},
	
		z: {
	
			get: function () {
	
				return this._z;
	
			},
	
			set: function ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			}
	
		},
	
		order: {
	
			get: function () {
	
				return this._order;
	
			},
	
			set: function ( value ) {
	
				this._order = value;
				this.onChangeCallback();
	
			}
	
		}
	
	} );
	
	Object.assign( Euler.prototype, {
	
		isEuler: true,
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._order );
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = _Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix = new Matrix4();
	
			return function setFromQuaternion( q, order, update ) {
	
				matrix.makeRotationFromQuaternion( q );
	
				return this.setFromRotationMatrix( matrix, order, update );
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new Quaternion();
	
			return function reorder( newOrder ) {
	
				q.setFromEuler( this );
	
				return this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	} );

	this.THREE = {
		Euler: Euler,
		Vector3: Vector3,
		Matrix3: Matrix3,
		Matrix4: Matrix4,
		Quaternion: Quaternion,
	};

})()
;
/*############################################################################*/
// AstroJS Base Math Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/

// global constants for math operations

// JDs in one JY
var JY2JD = 365.25;
// J2000 epoch in JD
var JD2000 = 2451545.0;

// use TAU, PI is wrong ;)
var PI = 1 * Math.PI;
var TAU = 2 * Math.PI;

// create namespace for constants
// we still define local variables
// wrap anonymous function around!
var AstroJS = this.AstroJS = {

	// astronomical units to meters
	AU2M: 1.495978707e+11,
	// astronomical units to kilometers
	AU2KM: 1.495978707e+8,
	// parsecs to meters
	PC2M: 30856776e9,
	// parsecs to AUs
	PC2AU: 206265,
	PC2LY: 3.26156,
	// metric conversion
	KM2M: 1000,
	// julian day conversion
	JY2JD: JY2JD,
	// time conversion
	JD2SEC: 24 * 60 * 60,
	// solar mass conversion
	MSOL2KG: 1.98855e30,
	// trig conversion factors
	DEG2RAD: TAU / 360,
	// not very useful!
	// HMS2RAD: TAU / 24,
	// HMS2DEG: 360 / 24,
}

// JulianYear    = 365.25      // days
// JulianCentury = 36525       // days
// BesselianYear = 365.2421988 // days

// create inverted functions
for (var name in AstroJS) {
	var units = name.split('2', 2);
	var inv = units.reverse().join('2');
	AstroJS[inv] = 1 / AstroJS[name];
}

AstroJS.exportConstants =
	// export function might be handy
	function exportAstroConstants(base)
	{
		for (var name in AstroJS) {
			base[name] = AstroJS[name];
		}
	}

AstroJS.DMS2RAD =
	// degrees, minutes, seconds to rad
	function DMS2RAD(d, m, s)
	{
		var dms = Math.abs(d);
		var sigma = d < 0 ? -1 : 1;
		dms += m / 60 + s / 60 / 60;
		return sigma * dms * DEG2RAD;
	}

AstroJS.HMS2RAD =
	// hours, minutes, seconds to rad
	function HMS2RAD(h, m, s)
	{
		return DMS2RAD(h, m, s) * 15;
	}

// additional exports
AstroJS.PI = PI;
AstroJS.TAU = TAU;
AstroJS.JD2000 = JD2000;

// Gravitational parameters for astronomic scale
// time in days, distance in AU, mass in sun-mass
// http://astronomy.stackexchange.com/a/7981
// GM * M2AU^3 * JD2SEC^2 * MSOL2KG
var GMJD = AstroJS.GMJD = {
	// VSOP2013 Masses system (INPOP10A)
	sun: 2.9591220836841438269e-04, // sun
	mer: 4.9125474514508118699e-11, // mer
	ven: 7.2434524861627027000e-10, // ven
	ear: 8.9970116036316091182e-10, // ear
	emb: 8.9970116036316091182e-10, // emb
	mar: 9.5495351057792580598e-11, // mar
	jup: 2.8253458420837780000e-07, // jup
	sat: 8.4597151856806587398e-08, // sat
	ura: 1.2920249167819693900e-08, // ura
	nep: 1.5243589007842762800e-08, // nep
	plu: 2.1886997654259696800e-12, // plu
	moon: 1.0936508975881017456e-11 // moon
};

// covert to a different time factor
// time in julian years, distance in AU
var GMJY = AstroJS.GMJY = {};
for (var name in GMJD) {
	GMJY[name] = GMJD[name];
	GMJY[name] *= 133407.5625;
	// => Math.pow(365.25, 2)
}

// covert to a different time factor
// time in julian seconds, distance in AU
// https://www.aanda.org/articles/aa/full_html/2013/09/aa21843-13/T1.html
/*
var GMJS = AstroJS.GMJS = {};
for (var name in GMJD) {
	GMJS[name] = GMJD[name];
	GMJS[name] /= 746496e4;
	// => Math.pow(86400, 2)
}
*/

AstroJS.CYCLE =
	// from 0 to TAU
	// one full cycle
	function CYCLE(rad)
	{
		rad %= TAU;
		if (rad < 0)
			rad += TAU;
		return rad;
	}

AstroJS.TURN =
	// from -PI to +PI
	// turn left/right
	function TURN(rad)
	{
		rad %= TAU;
		if (rad > PI)
			rad -= TAU;
		return rad;
	}

AstroJS.JDtoJY2K =
	// Julian Days to J2000
	function JDtoJY2K(JD)
	{
		// offset epoch and add ratio
		return (JD - JD2000) / JY2JD;
	}

AstroJS.JY2KtoJD =
	// J2000 to Julian Days
	function JY2KtoJD(J2K)
	{
		// add ratio and offset epoch
		return J2K * JY2JD + JD2000;
	}

// export into global scope
AstroJS.exportConstants(this);

// internal constants for math operations

// exponential factors
var KM2AU2 = Math.pow(AstroJS.KM2AU, 2);
var KM2AU3 = Math.pow(AstroJS.KM2AU, 3);

// maximum iterations to find
// a value in range for epsilon
// used in Newton-Raphson solver
var MAXLOOP = 12;
var EPSILON = 1e-12;

// polyfill for cube root function
// from https://developer.mozilla.org
Math.cbrt = Math.cbrt || function (x)
{
	var y = Math.pow(Math.abs(x), 1 / 3);
	return x < 0 ? -y : y;
};

// makes it easier to port C code
Math.fmod = Math.fmod || function (a, b)
{
	return a % b;
}
// THREEJS compatible implementation
if (typeof THREE != "undefined") {
	var Vector3 = this.Vector3 = THREE.Vector3;
	var Matrix3 = this.Matrix3 = THREE.Matrix3;
	var Matrix4 = this.Matrix4 = THREE.Matrix4;
	var Quaternion = this.Quaternion = THREE.Quaternion;
}
;
/*############################################################################*/
// AstroJS Orbit Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/
// http://www.lns.cornell.edu/~seb/celestia/orbital-parameters.html
// Similar module: https://github.com/jordanstephens/kepler.js
/*############################################################################*/
'use strict';

(function (exports)
{

	// Alias for math functions
	// Better compressibility
	// Saves about 0.4kb
	var abs = Math.abs;
	var pow = Math.pow;
	var sin = Math.sin;
	var cos = Math.cos;
	var sqrt = Math.sqrt;
	var cbrt = Math.cbrt;
	var atan2 = Math.atan2;

	// Ensure valid range
	function asin(angle) {
		return Math.asin(Math.min(1,
			Math.max(-1, angle)));
	}

	// Ensure valid range
	function acos(angle) {
		return Math.acos(Math.min(1,
			Math.max(-1, angle)));
	}

	/******************************************************************************/
	// Orbits can be created from orbital elements (6 independent parameters)
	// or from state vectors (position and velocity). In both cases we need 6
	// arguments to fully define an orbit. Most related parameters will be
	// calculated on construction. But certain parameters as the true anomaly
	// are a bit more complex to calculate from orbital elements, if only the
	// mean anomaly is given as initial parameters. They are lazy calculated
	// on demand, either by using the getter or invoking updateElements(true).
	/******************************************************************************/
	// To get state vectors for different times we just add a linear factor
	// to the mean anomaly (related to mean motion and period). To get the
	// actual state vectors from the mean anomaly we need to compute the
	// solution for Kepler's Equation via Newton-Raphson solver loop.
	/******************************************************************************/
	// Keep in mind that all angular parameters are in rads and that all
	// other units are linked to each other. This means that you can change
	// the units by adjusting the gravitational parameter. We use the solar
	// gravitational parameter by default with the units: au^3/(solm*day^2).
	// Normally in physics this parameter is measured in m^3/(kg*s^2). All
	// distance and time units must therefore be in the same units as `GM`.
	/******************************************************************************/
	// ToDo: finish and add tests for circular and hyperbola orbits.
	/******************************************************************************/

	function Orbit(arg)
	{

		var orbit = this;

		// internal use
		if (arg.empty) {
			return orbit;
		}

		// Give a warning about passing renamed parameter G
		if ('G' in arg) console.warn('G has been renamed to GM');

		// the gravitational parameter is very important and must
		// match all others in terms of the units. In physics the
		// units are by default m^3/(kg*s^2), but for astronomical
		// uses we most often want to use au^3/(solm*day^2).
		orbit._GM = arg.GM || arg.G || Orbit.GMP.sun,
			orbit._t = arg.epoch || arg.t || 0;
		orbit.translate = arg.translate || null;

		// create state vectors from input parameters
		if ('x' in arg && 'y' in arg && 'z' in arg) {
			orbit._r = new Vector3(arg.x, arg.y, arg.z);
		}
		else if ('rx' in arg && 'ry' in arg && 'rz' in arg) {
			orbit._r = new Vector3(arg.rx, arg.ry, arg.rz);
		}
		if ('X' in arg && 'Y' in arg && 'Z' in arg) {
			orbit._v = new Vector3(arg.X, arg.Y, arg.Z);
		}
		else if ('vx' in arg && 'vy' in arg && 'vz' in arg) {
			orbit._v = new Vector3(arg.vx, arg.vy, arg.vz);
		}

		if ('r' in arg && 'v' in arg) {
			var r = arg.r, v = arg.v;
			// create new vectors (want a clone anyway)
			orbit._r = new Vector3(r.x, r.y, r.z);
			orbit._v = new Vector3(v.x, v.y, v.z);
		}

		// set status for state vectors
		orbit.vectors = !!(orbit._r && orbit._v);

		// get other parameters from arg
		// unknown parameters are ignored
		var vars = 'aeiMnPLcCwWOkhqpG'.split('');
		for (var i in vars) {
			if (arg.hasOwnProperty(vars[i])) {
				orbit['_' + vars[i]] = arg[vars[i]];
			}
		}

		// precession periods
		orbit._PW = arg.PW || 0;
		orbit._PO = arg.PO || 0;

		// orbit may has name
		if ('name' in arg) {
			orbit.name = arg.name;
		}

		// resolve if not lazy
		if (!orbit.lazy) {
			orbit.updateElements();
			orbit.requireElements();
		}

	}
	// EO Orbit ctor

	// use mass system
	// has julian days
	Orbit.GMP = GMJD;

	// optimized for minifier
	var Klass = Orbit.prototype;

	/******************************************************************************/
	// clone the existing orbital
	/******************************************************************************/

	// copy existing orbit and return clone
	Klass.clone = function clone(jy2k)
	{
		var orbit = this;
		var epoch = orbit._t || 0;
		var dt = jy2k == null ?
			0 :  jy2k - epoch;
		// create an empty object (internal use)
		var clone = new Orbit({ empty: true });
		// avoid unnecessary cloning of objects
		if (dt) { delete orbit._v; delete orbit._r; }
		// process all properties
		for (var key in orbit) {
			if (orbit.hasOwnProperty(key)) {
				// invoke nested clone functions (vectors)
				if (orbit[key] && typeof orbit[key].clone == 'function')
				{ clone[key] = orbit[key].clone(); }
				else { clone[key] = orbit[key]; }
			}
		}
		// optionally call update
		if (dt) clone._update(jy2k);
		// return copy
		return clone;
	}

	/******************************************************************************/
	// check current object for valid resolved state
	/******************************************************************************/
	Klass.checkElements = function checkElements(full)
	{
		var orbit = this;
		// most basic check for initial pre-calculations
		if (!orbit.elements) throw ('Orbitals not calculated');
		// do some basic checks for needed orbital elements
		if (!('_i' in orbit)) throw ('Orbit is missing inclination (i)');
		if (!('_e' in orbit)) throw ('Orbit is missing eccentricity (e)');
		if (!('_a' in orbit)) throw ('Orbit is missing semi-major axis (a)');
		if (!('_b' in orbit)) throw ('Orbit is missing semi-minor axis (b)');
		if (!('_l' in orbit)) throw ('Orbit is missing semi-latus rectum (l)');
		if (!('_c' in orbit)) throw ('Orbit is missing periapsis (c)');
		if (!('_C' in orbit)) throw ('Orbit is missing apoapsis (C)');
		if (!('_L' in orbit)) throw ('Orbit is missing mean longitude (L)');
		if (!('_O' in orbit)) throw ('Orbit is missing right ascending node (O)');
		if (!('_T' in orbit)) throw ('Orbit is missing time of periapsis (w)');
		if (!('_t' in orbit)) throw ('Orbit is missing time of reference epoch (t)');
		if (!('_w' in orbit)) throw ('Orbit is missing argument of periapsis (w)');
		if (!('_W' in orbit)) throw ('Orbit is missing longitude of the periapsis (W)');
		if (!('_n' in orbit)) throw ('Orbit is missing mean motion (n)');
		if (!('_M' in orbit)) throw ('Orbit is missing mean anomaly (M)');
		if (!('_P' in orbit)) throw ('Orbit is missing orbital period (P)');
		if (!('_A' in orbit)) throw ('Orbit is missing angular momentum (A)');
		if (!('_c' in orbit)) throw ('Orbit is missing pericenter (c)');
		if (!('_C' in orbit)) throw ('Orbit is missing apocenter (C)');
		// check if eccentricity is inside valid boundaries (0-1)
		if (orbit._e < 0) throw ('Negative eccentricity is invalid');
		if (orbit._e > 1) throw ('Eccentricity must not be hyperbolic (> 1)');
		if (orbit._e == 1) throw ('Eccentricity must not be parabolic (== 1)');
		// state vectors (r and v) are not tested here ...
		if (full) if (!('_m' in orbit)) throw ('Orbit is missing true anomaly (m)');
		if (full) if (!('_B' in orbit)) throw ('Orbit is missing radial velocity (B)');
		if (full) if (!('_E' in orbit)) throw ('Orbit is missing eccentric anomaly (E)');
	}

	/******************************************************************************/
	// ensure certain orbital elements exist: aeiWLMOw
	/******************************************************************************/
	Klass.requireElements = function requireElements(full)
	{
		// invoke resolver (fully)
		this.updateElements(full);
		this.checkElements(full);
		// chain-able
		return this;
	}

	/******************************************************************************/
	// resolve orbital elements as far as possible
	/******************************************************************************/
	Klass.updateElements = function updateElements(full)
	{

		var orbit = this;
		// only resolve elements once
		if (orbit.elements) return orbit;
		// will calculate now
		orbit.elements = true;

		/********************************************************/
		// resolve from state vectors (r, v)
		/********************************************************/

		// check main state vectors
		if ('_r' in orbit && '_v' in orbit) {

			var r = orbit._r, v = orbit._v,
				GM = orbit._GM, rl = r.length();

			// specific relative angular momentum
			orbit._A3 = r.clone().cross(v);
			orbit._A2 = orbit._A3.lengthSq();
			orbit._A = sqrt(orbit._A2);
			// calculate radial velocity
			orbit._B = r.dot(v) / rl;

			// calculate eccentricity vector
			var e3 = orbit._e3 = r.clone().multiplyScalar(v.lengthSq() - (GM / rl))
				.sub(v.clone().multiplyScalar(rl * orbit._B)).multiplyScalar(1 / GM);
			// get eccentricity value from vector
			var e2 = e3.lengthSq(), e = orbit._e = sqrt(e2);
			// get inclination (i) via orbital momentum vector
			orbit._i = acos(orbit._A3.z / orbit._A);

			// calculate semilatus rectum ()
			orbit._l = orbit._A2 / GM;
			// and periapsis (c) and apoapsis (C)
			orbit._c = orbit._l / (1 + e);
			orbit._C = orbit._l / (1 - e);
			// and finally semi-major axis (a)
			orbit._a = (orbit._C + orbit._c) / 2;

			// pre-calculate node line
			var nx = - orbit._A3.y,
				ny = + orbit._A3.x;
			var nl = sqrt(nx * nx + ny * ny);

			// calculate ascending node (O)
			var omega = nl == 0 ? 0 : acos(nx / nl);
			orbit._O = ny < 0 ? (TAU - omega) : omega;

			// calculate argument of periapsis ()
			var nedot = nx * e3.x +
				ny * e3.y;
			if (nl === 0 || e === 0) { orbit._w = 0; }
			else { orbit._w = acos(nedot / nl / e); }
			if (e3.z < 0) { orbit._w *= -1; }

			// calculate true anomaly
			var u; // argument of latitude
			// case for circular orbit
			// and without inclination
			if (e === 0 && nl === 0) {
				// orbit needs a test case
				u = acos(r.x / rl);
			}
			// circular orbit
			// with inclination
			else if (e === 0) {
				// orbit needs a test case
				var nrdot = nx * r.x + ny * r.y;
				u = acos(nrdot / (nl * rl));
			}
			// elliptic orbit
			else {
				var redot = e3.x * r.x + e3.y * r.y + e3.z * r.z;
				u = acos(redot / e / rl);
			}
			// bring into correct range via simple check
			var m = orbit._m = orbit._B < 0 ? (TAU - u) : u;

			// for elliptic orbits
			if (e < 1) {
				// calculate eccentric anomaly
				var E = orbit._E = CYCLE(atan2(
					sqrt(1 - e * e) * sin(m),
					e + cos(m)
				));
				// calculate mean anomaly
				orbit._M = E - e * sin(E);
			}
			// for hyperbolic orbits
			else if (e > 1) {
				// calculate eccentric anomaly
				var E = orbit._E = CYCLE(atan2(
					sqrt(1 - e * e) * sin(m),
					e + cos(m)
				));
				// calculate mean anomaly
				orbit._M = E - e * sin(E);
			}

			// calculate mean anomaly
			orbit._M = E - e * sin(E);

		}
		// EO state vectors

		/********************************************************/
		// VSOP87 uses some exotic orbital elements
		// not sure if they have a technical name
		/********************************************************/

		// VSOP arguments (k/h -> W/e)
		// Called pi (W) in VSOP87
		// k = e*cos(W) [rad]
		// h = e*sin(W) [rad]
		if ('_k' in orbit && '_h' in orbit) {
			// periapsis longitude directly from p and q
			orbit._W = atan2(orbit._h, orbit._k);
			// orbit._e = orbit._k / cos(orbit._W);
			orbit._e = orbit._h / sin(orbit._W);
		}

		// VSOP arguments (q/p -> O/i)
		// Called omega (O) in VSOP87
		// q = sin(i/2)*cos(O) [rad]
		// p = sin(i/2)*sin(O) [rad]
		if ('_q' in orbit && '_p' in orbit) {
			// ascending node directly from p and q
			orbit._O = atan2(orbit._p, orbit._q);
			// values for inclination
			var d = orbit._p - orbit._q,
				// using the faster but equivalent form for
				// dt = sin(orbit._O) - cos(orbit._O);
				dt = - sqrt(2) * sin(PI / 4 - orbit._O);
			// now calculate inclination
			orbit._i = 2 * asin(d / dt);
		}

		/********************************************************/
		// directly related parameters for a
		// more stuff is calculated later on
		/********************************************************/

		if ('_n' in orbit && !('_a' in orbit)) {
			// mean motion is translated directly to size via
			orbit._a = cbrt(orbit._GM / orbit._n / orbit._n);
		}
		if ('_P' in orbit && !('_a' in orbit)) {
			// period is translated directly to size via GM
			var PTAU = orbit._P / TAU; // reuse for square
			orbit._a = cbrt(orbit._GM * PTAU * PTAU);
		}

		/********************************************************/
		// semi-major axis and eccentricity
		// from apocenter and pericenter
		// C = a * (1 + e), c = a * (1 - e)
		/********************************************************/
		if (!('_a' in orbit)) { // semi-major axis
			if ('_c' in orbit && '_C' in orbit) { orbit._a = (orbit._C + orbit._c) / 2; }
			else if ('_e' in orbit && '_C' in orbit) { orbit._a = orbit._C / (1 + orbit._e); }
			else if ('_c' in orbit && '_e' in orbit) { orbit._a = orbit._c / (1 - orbit._e); }
		}
		if (!('_e' in orbit)) { // eccentricity
			if ('_c' in orbit && '_C' in orbit) { orbit._e = 1 - orbit._c / orbit._a; }
			else if ('_a' in orbit && '_C' in orbit) { orbit._e = orbit._C / orbit._a - 1; }
			else if ('_c' in orbit && '_a' in orbit) { orbit._e = 1 - orbit._c / orbit._a; }
		}

		/********************************************************/
		// orbital size parameters
		// a * l = b * b
		// l = a * (1 - e*e)
		// b = a * sqrt(1 - e*e)
		// need 2 independent arguments
		// there are 6 valid combination
		/********************************************************/

		// 3 valid options with e
		if ('_e' in orbit) {
			var e2term = 1 - orbit._e * orbit._e;
			if ('_a' in orbit) {
				orbit._l = orbit._a * e2term;
				orbit._b = sqrt(orbit._a * orbit._l);
			}
			else if ('_b' in orbit) {
				orbit._a = orbit._b / sqrt(e2term);
				orbit._l = orbit._a * e2term;
			}
			else if ('_l' in orbit) {
				orbit._a = orbit._l / e2term;
				orbit._b = sqrt(orbit._a * orbit._l);
			}
		}
		// 2 valid options with a
		else if ('_a' in orbit) {
			if ('_b' in orbit) {
				orbit._l = orbit._b * orbit._b / orbit._a;
				orbit._e = sqrt(1 - orbit._l / orbit._a);
			}
			else if ('_l' in orbit) {
				orbit._e = sqrt(1 - orbit._l / orbit._a);
				orbit._b = sqrt(orbit._a * orbit._l);
			}
		}
		// only one valid options left
		else if ('_b' in orbit && '_l' in orbit) {
			orbit.a = orbit._b * orbit._b / orbit._l;
			orbit._e = sqrt(1 - orbit._l / orbit._a);
		}

		// calculate orbital period (P)
		if ('_a' in orbit && !('_P' in orbit)) {
			// calculate dependants via gravitational parameter
			orbit._P = (TAU / sqrt(orbit._GM)) * pow(orbit._a, 1.5);
		}
		// calculate mean motion (n)
		if ('_P' in orbit && !('_n' in orbit)) {
			orbit._n = TAU / orbit._P;
		}
		// specific relative angular momentum (A)
		if ('_P' in orbit && !('_A' in orbit)) {
			if ('_a' in orbit && '_b' in orbit) {
				orbit._A = TAU * orbit._a * orbit._b / orbit._P;
			}
		}

		// apsis from eccentricity and semi-major axis
		if ('_a' in orbit && '_e' in orbit) {
			if (!('_c' in orbit)) orbit._c = orbit._a * (1 - orbit._e);
			if (!('_C' in orbit)) orbit._C = orbit._a * (1 + orbit._e);
		}

		/********************************************************/
		// orientation parameters
		// W = L - M = O + w
		// need 3 independent arguments
		// there are 8 valid combination
		/********************************************************/

		// 5 valid options with L
		if ('_L' in orbit) {
			if ('_M' in orbit) {
				// calculate the main dependants
				orbit._W = orbit._L - orbit._M;
				// calculate additional dependants
				if ('_O' in orbit) orbit._w = orbit._W - orbit._O;
				else if ('_w' in orbit) orbit._O = orbit._W - orbit._w;
			}
			else if ('_W' in orbit) {
				// calculate the main dependants
				orbit._M = orbit._L - orbit._W;
				// calculate additional dependants
				if ('_O' in orbit) orbit._w = orbit._W - orbit._O;
				else if ('_w' in orbit) orbit._O = orbit._W - orbit._w;
			}
			else if ('_O' in orbit && '_w' in orbit) {
				// calculate the main dependants
				orbit._W = orbit._O + orbit._w;
				orbit._M = orbit._L - orbit._W;
			}
			else {
				throw ('Orbit incomplete')
			}
		}
		// 2 valid options with O
		else if ('_O' in orbit) {
			if ('_w' in orbit) {
				// calculate the main dependants
				orbit._W = orbit._O + orbit._w;
				// calculate additional dependants
				if ('_M' in orbit) orbit._L = orbit._M + orbit._W;
				// the L case is already handled in the very first if
				// else if ('_L' in orbit) orbit._M = orbit._L - orbit._W;
			}
			else if ('_W' in orbit) {
				// calculate the main dependants
				orbit._w = orbit._W - orbit._O;
				// calculate additional dependants
				if ('_M' in orbit) orbit._L = orbit._M + orbit._W;
				// the L case is already handled in the very first if
				// else if ('_L' in orbit) orbit._M = orbit._L - orbit._W;
			}
			else {
				throw ('Orbit incomplete')
			}
		}
		// only one valid options left
		else if ('_M' in orbit && '_w' in orbit && '_W' in orbit) {
			orbit._L = orbit._W + orbit._M;
			orbit._O = orbit._W - orbit._w;
		}

		/********************************************************/
		// optionally do expensive calculations
		/********************************************************/

		if (full) orbit.m();

		/********************************************************/
		// do range corrections
		/********************************************************/

		// bring parameters into correct ranges
		if ('_W' in orbit) orbit._W = TURN(orbit._W); // verified
		if ('_L' in orbit) orbit._L = CYCLE(orbit._L); // verified
		if ('_M' in orbit) orbit._M = CYCLE(orbit._M); // verified
		if ('_O' in orbit) orbit._O = CYCLE(orbit._O); // verified
		if ('_w' in orbit) orbit._w = TURN(orbit._w); // verified

		/********************************************************/
		// TODO: better time epoch support
		/********************************************************/
		if ('_M' in orbit && '_n') {
			orbit._T = - orbit._M / orbit._n;
		}

		// chain-able
		return orbit;

	}

	/*############################################################################*/
	// Next functions are needed to calculate eccentricity anomaly and
	// related parameter (i.e. from mean anomaly to true anomaly).
	/*############################################################################*/

	/******************************************************************************/
	// In orbital mechanics, eccentric anomaly (E) is an angular parameter that
	// defines the position of a body that is moving along an elliptic Kepler
	// orbit. The eccentric anomaly (E) is one of three angular parameters
	// ("anomalies") that define a position along an orbit, the other two
	// being the true anomaly (m) and the mean anomaly (M).
	/******************************************************************************/
	Klass.E = function eccentricAnomaly(jy2k)
	{

		var orbit = this;
		var epoch = orbit._t || 0;
		var dt = jy2k == null ?
			0 :  jy2k - epoch;

		// return cached
		if ('_E' in orbit && !dt) {
			return orbit._E;
		}

		// basic parameters
		var e = orbit._e, // must
			m = orbit._m, // either
			M = orbit._M; // ... or

		// from true anomaly (m)
		// much easier calculation
		if (!dt && e != null && m != null) {
			return orbit._E = CYCLE(atan2(
				sqrt(1 - e * e) * sin(m),
				e + cos(m)
			));
		}

		// from mean anomaly (M)
		// M = L - W (W = O + w)
		// more expensive solver loop
		if (e != null && M != null) {
			// advance mean anomaly for new time offset
			if (dt) M += CYCLE(orbit._n * dt);
			// NOTE: not sure why line below needs the if
			// TODO: find a unit test to exhibit edge case
			// if (!dt) M = CYCLE(orbit._n * (- orbit._T));
			// prepare for solution solver
			var E = e < 0.8 ? M : PI;
			// var F = E - e * sin(M) - M;
			// Newton-Raphson method to solve
			// f(E) = M - E + e * sin(E) = 0
			var f, dfdE, dE = 1;
			for (var it = 0; abs(dE) > EPSILON && it < MAXLOOP; ++it) {
				f = M - E + e * sin(E);
				dfdE = e * cos(E) - 1.0;
				dE = f / dfdE;
				E -= dE; // next iteration
			}
			// clamp range
			E = CYCLE(E);
			// cache for zero time
			if (!dt) orbit._E = E;
			// return result
			return E;
		}

		// remove in release version
		throw ('Invalid orbital state');

		// fail gracefully
		return null;
	}

	/******************************************************************************/
	// In celestial mechanics, true anomaly is an angular parameter that defines the
	// position of a body moving along a Keplerian orbit. It is the angle between the
	// direction of periapsis and the current position of the body, as seen from the
	// main focus of the ellipse (the point around which the object orbits).
	/******************************************************************************/
	Klass.m = function trueAnomaly(E)
	{
		var orbit = this;
		if (arguments.length === 0) {
			// return cached
			if ('_m' in orbit) {
				return orbit._m;
			}
			// from eccentric anomaly
			// most expensive step
			var hE = orbit.E() / 2;
			// calculate the true anomaly
			return orbit._m = CYCLE(2 * atan2(
				sqrt(1 + orbit._e) * sin(hE),
				sqrt(1 - orbit._e) * cos(hE)
			));
		}
		else {
			// calculate the true anomaly
			return CYCLE(2 * atan2(
				sqrt(1 + orbit._e) * sin(E / 2),
				sqrt(1 - orbit._e) * cos(E / 2)
			));
		}
	}

	/*############################################################################*/
	// additional helper functions (expensive)
	// only use them if you really need too
	// no direct way from orbital elements yet
	/*############################################################################*/

	/******************************************************************************/
	// The radial velocity of an object with respect to a given point is the rate of
	// change of the distance between the object and the point. That is, the radial
	// velocity is the component of the object's velocity that points in the direction
	// of the radius connecting the object and the point. In astronomy, the point is
	// usually taken to be the observer on Earth, so the radial velocity then denotes
	// the speed with which the object moves away from or approaches the Earth.
	/******************************************************************************/
	// Klass.vt = function tangentialVelocity() {}
	/******************************************************************************/
	Klass.B = function radialVelocity()
	{
		var orbit = this;
		// return cached value
		if ('_B' in orbit) return orbit._B;
		// calculate state vectors
		var r = orbit.r(), v = orbit.v();
		// get radial velocity from state vectors
		return orbit._B = r.dot(v) / r.length();
	};

	/******************************************************************************/
	// In celestial mechanics, the eccentricity vector of a Kepler orbit is the
	// dimensionless vector with direction pointing from apoapsis to periapsis and
	// with magnitude equal to the orbit's scalar eccentricity. For Kepler orbits
	// the eccentricity vector is a constant of motion. Its main use is in the
	// analysis of almost circular orbits, as perturbing (non-Keplerian) forces
	// on an actual orbit will cause the osculating eccentricity vector to change
	// continuously. For the eccentricity and argument of periapsis parameters,
	// eccentricity zero (circular orbit) corresponds to a singularity.
	/******************************************************************************/
	Klass.e3 = function eccentricity3()
	{
		var orbit = this;
		// return cached value
		if ('_e3' in orbit) return orbit._e3;
		// force state vector calculation
		var r = orbit.r(), v = orbit.v();
		if (r !== null && v !== null) {
			return orbit._e3 = r.clone().multiplyScalar(
				v.lengthSq() - (orbit._GM / r.length())
			).sub(
				v.clone().multiplyScalar(r.length() * orbit.B())
				).multiplyScalar(1 / orbit._GM);
		}
	}

	/*############################################################################*/
	// getter functions for elements that are available after resolving
	/*############################################################################*/

	// Orbit inclination is the minimum angle between a reference plane and the
	// orbital plane or axis of direction of an object in orbit around another
	// object. The inclination is one of the six orbital parameters describing
	// the shape and orientation of a celestial orbit. It is the angular distance
	// of the orbital plane from the plane of reference (usually the primary's
	// equator or the ecliptic), normally stated in degrees. In the Solar System,
	// orbital inclination is usually stated with respect to Earth's orbit.
	Klass.i = function inclination() { return this._i; }

	// The orbital eccentricity of an astronomical object is a parameter that
	// determines the amount by which its orbit around another body deviates
	// from a perfect circle. A value of 0 is a circular orbit, values between
	// 0 and 1 form an elliptical orbit, 1 is a parabolic escape orbit, and
	// greater than 1 is a hyperbola. The term derives its name from the
	// parameters of conic sections, as every Kepler orbit is a conic section.
	// It is normally used for the isolated two-body problem, but extensions
	// exist for objects following a rosette orbit through the galaxy.
	Klass.e = function eccentricity() { return this._e; }

	// In geometry, the major axis of an ellipse is its longest diameter:
	// a line segment that runs through the center and both foci, with ends
	// at the widest points of the perimeter. The semi-major axis is on half
	// of the major axis, and thus runs from the centre, through a focus, and
	// to the perimeter. Essentially, it is the radius of an orbit at the
	// orbit's two most distant points. For the special case of a circle, the
	// semi-major axis is the radius. One can think of the semi-major axis as
	// an ellipse's long radius. The length of the semi-major axis a of an
	// ellipse is related to the semi-minor axis's length b through the
	// eccentricity e and the semilatus rectum .
	Klass.a = function semiMajorAxis() { return this._a; }
	Klass.b = function semiMinorAxis() { return this._b; }
	Klass.l = function semilatusRectum() { return this._l; }

	// The point of a body's elliptical orbit about the system's centre of mass where
	// the distance between the body and the centre of mass is at its maximum.
	// For some celestial bodies, specialised terms are used (aphelion/apogee).
	Klass.C = function apocenter() { return this._C; }
	// The point of a body's elliptical orbit about the system's centre of mass where
	// the distance between the body and the centre of mass is at its minimum.
	// For some celestial bodies, specialised terms are used (perihelion/perigee).
	Klass.c = function pericenter() { return this._c; }

	// Mean longitude is the ecliptic longitude at which an orbiting body
	// could be found if its orbit were circular and free of perturbations.
	// While nominally a simple longitude, in practice the mean longitude
	// is a hybrid angle.
	Klass.L = function meanLongitude() { return this._L; }

	// The longitude of the ascending node ( or ) is one of the orbital
	// elements used to specify the orbit of an object in space. It is the
	// angle from a reference direction, called the origin of longitude,
	// to the direction of the ascending node, measured in a reference plane.
	// The ascending node is the point where the orbit of the object passes
	// through the plane of reference.
	Klass.O = function ascendingNode() { return this._O; }

	// The argument of periapsis (also called argument of perifocus or
	// argument of pericenter), is one of the orbital elements () of
	// an orbiting body. Parametrically,  is the angle from the body's
	// ascending node to its periapsis, measured in the direction of motion.
	Klass.w = function argOfPeriapsis() { return this._w; }

	// The time of pericenter passage when the orbiting body passes through
	// the pericenter, closest to the central body. The mean anomaly is 0.0
	// when the orbiting body is at pericenter, so defining the orbital
	// elements at the epoch T (the time of the pericenter passage)
	// eliminates the need to determine the mean anomaly.
	Klass.T = function timeOfPericenter() { return this._T; }

	// In celestial mechanics, the longitude of the periapsis () of
	// an orbiting body is the longitude (measured from the point of
	// the vernal equinox) at which the periapsis (closest approach
	// to the central body) would occur if the body's inclination were
	// zero. For motion of a planet around the Sun, this position could
	// be called longitude of perihelion. The longitude of periapsis is
	// a compound angle, with part of it being measured in the plane of
	// reference and the rest being measured in the plane of the orbit.
	// Likewise, any angle derived from the longitude of periapsis (e.g.
	// mean longitude and true longitude) will also be compound.
	Klass.W = function longitudeOfPeriapsis() { return this._W; }

	// In orbital mechanics, mean motion is the angular speed required
	// for a body to complete one orbit, assuming constant speed in a
	// circular orbit which completes in the same time as the variable
	// speed, elliptical orbit of the actual body.
	Klass.n = function meanMotion() { return this._n; }

	// In a closed system, no torque can be exerted on any matter
	// without the exertion on some other matter of an equal and
	// opposite torque. Hence, angular momentum can be exchanged
	// between objects in a closed system, but total angular momentum
	// before and after an exchange remains constant (is conserved)
	Klass.A = function angularMomentum() { return this._A; }

	// In celestial mechanics, the mean anomaly is an angle used in
	// calculating the position of a body in an elliptical orbit in the
	// classical two-body problem. It is the angular distance from the
	// pericenter which a fictitious body would have if it moved in a
	// circular orbit, with constant speed, in the same orbital period
	// as the actual body in its elliptical orbit. It is also the
	// product of mean motion and time since pericenter passage.
	Klass.M = function meanAnomaly() { return this._M; }

	// The orbital period is the time taken for a given object to make one
	// complete orbit around another object. When mentioned without further
	// qualification in astronomy this refers to the sidereal period of an
	// astronomical object, which is calculated with respect to the stars.
	Klass.P = function orbitalPeriod() { return this._P; }

	// In celestial mechanics, the standard gravitational parameter  of a
	// celestial body is the product of the gravitational constant G and
	// the mass M of the body. For several objects in the Solar System,
	// the value of  is known to greater accuracy than either G or M.
	// The SI units of the standard gravitational parameter are m3 s2.
	// However, units of km3 s2 are frequently used in the scientific
	// literature and in spacecraft navigation. AstroJS normally will
	// use units of AU3 and julian days or years (e.g. AstroJS.GMJY).
	Klass.GM = function gravitationalParameter() { return this._GM; }

	// In celestial mechanics, apsidal precession (or apsidal advance) is the
	// precession (gradual rotation) of the line connecting the apsides (line
	// of apsides) of an astronomical body's orbit. The apsides are the orbital
	// points closest (periapsis) and farthest (apoapsis) from its primary body.
	// The apsidal precession is the first time derivative of the argument of
	// periapsis, one of the six main orbital elements of an orbit. Apsidal
	// precession is considered positive when the orbit's axis rotates in the
	// same direction as the orbital motion. An apsidal period is the time
	// interval required for an orbit to precess through 360.
	Klass.PW = function apsidalPrecession() { return this._PW; }

	// Nodal precession is the precession of the orbital plane of a satellite
	// around the rotational axis of an astronomical body such as Earth. This
	// precession is due to the non-spherical nature of a rotating body, which
	// creates a non-uniform gravitational field. The direction of precession
	// is opposite the direction of revolution. 
	Klass.PO = function nodalPrecession() { return this._PO; }

	// In chronology and periodization, an epoch or reference epoch is an
	// instant in time chosen as the origin of a particular calendar era.
	// The "epoch" serves as a reference point from which time is measured. 
	Klass.epoch = function epoch() { return this._t; }

	/*############################################################################*/
	// convert to vsop parameters (never seen them anywhere else)
	// those are calculated on demand, so you need to call me first
	/*############################################################################*/

	// q: sin(i/2)*cos(O) (vsop)
	Klass.q = function vsopPeriapsis()
	{
		var orbit = this;
		// return cached calculation
		if ('_q' in orbit) return orbit._q;
		// calculation given in vsop87 example.f
		return orbit._q = cos(orbit._O)
			* sin(orbit._i / 2);
	};

	// p: sin(i/2)*sin(O) (vsop)
	Klass.p = function vsopApoapsis()
	{
		var orbit = this;
		// return cached calculation
		if ('_p' in orbit) return orbit._p;
		// calculation given in vsop87 example.f
		return orbit._p = sin(orbit._O)
			* sin(orbit._i / 2);
	};

	// k: e*cos(W) (vsop)
	Klass.k = function vsopK()
	{
		var orbit = this;
		// return cached calculation
		if ('_k' in orbit) return orbit._k;
		// calculation given in vsop87 example.f
		return orbit._k = orbit._e * cos(orbit._W);
	};

	// h: e*sin(W) (vsop)
	Klass.h = function vsopH()
	{
		var orbit = this;
		// return cached calculation
		if ('_h' in orbit) return orbit._h;
		// calculation given in vsop87 example.f
		return orbit._h = orbit._e * sin(orbit._W);
	};

	/*############################################################################*/
	// calculate state vectors from orbital elements
	// TODO: implement for different time offsets (TBD)
	/*############################################################################*/

	// update orbital state for new epoch
	// advance position and reset some states
	// for dt = P, mean anomaly does not change
	// Note: could just get state at jy2k and
	// convert the result back to an orbit.
	Klass._update = function update(jy2k)
	{
		var orbit = this;
		var epoch = orbit._t || 0;
		var dt = jy2k == null ?
			0 :  jy2k - epoch;
		// check if elements are already resolved
		if (!orbit.elements) orbit.resolveElements(true);
		// advance mean anomaly for new time
		orbit._M = CYCLE(orbit._n * (dt - orbit._T));
		// adjust mean longitude for new time
		orbit._L = CYCLE(orbit._M + orbit._W);
		// Argument of periapsis precession
		if (orbit._PW) orbit._w = dt / orbit._PW * TAU;
		// Longitude of the ascending node precession
		if (orbit._PO) orbit._O += dt / orbit._PO * TAU;
		// update to new epoch
		orbit._t = dt + epoch;
		// reset dependent parameters
		delete orbit._E; delete orbit._m;
		// invalidate state vectors
		delete orbit._r; delete orbit._v;
		// chainable
		return orbit;
	}

	/*
	// orbital elements to spherical position (lon/lat/r)
	Klass.sph = function spherical (jy2k)
	{
		var epoch = this._t || 0;
		var dt = jy2k == null ?
			0 :  jy2k - epoch;
		// check if elements are already resolved
		if (!this.elements) this.resolveElements(true);
		dt = dt || 0; // time offset
	}
	*/

	// orbital elements to rectangular position (x/y/z)
	Klass.state = function state(jy2k)
	{

		var orbit = this, mat;
		var epoch = orbit._t || 0;
		var dt = jy2k == null ?
			0 :  jy2k - epoch;

		// check if elements are already resolved
		if (!orbit.elements) orbit.resolveElements(true);

		// return cached result for our epoch
		// ToDo: also cache last epoch offsets?
		if (!dt && '_r' in orbit && '_v' in orbit)
		{
			// state result
			return {
				r: orbit._r,
				v: orbit._v,
				epoch: epoch,
				orbit: orbit,
				GM: orbit._GM
			};
		}

		var e = orbit._e, a = orbit._a, i = orbit._i,
			O = orbit._O, w = orbit._w, M = orbit._M,
			E = orbit.E(jy2k), // eccentric anomaly
			m = orbit.m(E); // true anomaly

		// Argument of periapsis precession
		if (orbit._PW) w += dt / orbit._PW * TAU;
		// Longitude of the ascending node precession
		if (orbit._PO) O += dt / orbit._PO * TAU;

		// Distance to true anomaly position
		var r = a * (1.0 - e * cos(E));
		var vf = sqrt(orbit._GM * a) / r;

		// Perifocal reference plane
		var rx = r * cos(m),
			ry = r * sin(m),
			vx = vf * - sin(E),
			vy = vf * sqrt(1.0 - e * e) * cos(E);

		// Pre-calculate elements for rotation matrix
		var sinO = sin(O), cosO = cos(O),
			sinI = sin(i), cosI = cos(i),
			sinW = sin(w), cosW = cos(w),
			sinWcosO = sinW * cosO, sinWsinO = sinW * sinO,
			cosWcosO = cosW * cosO, cosWsinO = cosW * sinO,
			sinWcosI = sinW * cosI,
			FxX = cosWcosO - sinWcosI * sinO,
			FyX = cosWsinO + sinWcosI * cosO,
			FxY = cosWsinO * cosI + sinWcosO,
			FyY = cosWcosO * cosI - sinWsinO,
			FzX = sinW * sinI,
			FzY = cosW * sinI;

		// Equatorial position
		var r = new Vector3(
			rx * FxX - ry * FxY,
			rx * FyX + ry * FyY,
			rx * FzX + ry * FzY
		);
		// Equatorial velocity
		var v = new Vector3(
			vx * FxX - vy * FxY,
			vx * FyX + vy * FyY,
			vx * FzX + vy * FzY
		);
		// cache results if no time offset
		if (!dt) orbit._r = r, orbit._v = v;
		// return result object with reference
		// ToDo: maybe add position object
		// To calculate ra/dec and more stuff
		return {
			r: r,
			v: v,
			epoch: epoch,
			orbit: orbit,
			GM: orbit._GM
		};

	}
	// EO state

	/*############################################################################*/
	// getters for state vectors
	/*############################################################################*/

	// r: position state vector
	Klass.r = function position3(jy2k)
	{
		// calculate at epoch time
		// state will cache results
		var state = this.state(jy2k);
		// return vector
		return state.r;
	}

	// v: velocity state vector
	Klass.v = function velocity3(jy2k)
	{
		// calculate at epoch time
		// state will cache results
		var state = this.state(jy2k);
		// return vector
		return state.v;
	}

	/*############################################################################*/
	// add fully named getter functions if preferred
	/*############################################################################*/

	// orbital elements that are always calculated
	// these can be used as orbital input arguments
	Klass.inclination = Klass.i;
	Klass.eccentricity = Klass.e;
	Klass.semiMajorAxis = Klass.a;
	Klass.semiMinorAxis = Klass.b;
	Klass.semilatusRectum = Klass.l;
	Klass.meanLongitude = Klass.L;
	Klass.ascendingNode = Klass.O;
	Klass.argOfPericenter = Klass.w;
	Klass.argOfPeriapsis = Klass.w;
	Klass.timeOfPericenter = Klass.T;
	Klass.longitudeOfPericenter = Klass.W;
	Klass.meanMotion = Klass.n;
	Klass.meanAnomaly = Klass.M;
	Klass.orbitalPeriod = Klass.P;
	Klass.angularMomentum = Klass.A;
	Klass.gravitationalParameter = Klass.GM;

	// first time derivates (precession periods)
	Klass.apsidalPrecession = Klass.PW;
	Klass.nodalPrecession = Klass.PO;

	// additional orbital elements only on demand
	// these must not be used as orbital input arguments
	Klass.trueAnomaly = Klass.m;
	Klass.radialVelocity = Klass.B;
	Klass.eccentricAnomaly = Klass.E;
	// additional parameters are calculated on demand
	Klass.apoapsis = Klass.C;
	Klass.aphelion = Klass.C;
	Klass.apocenter = Klass.C;
	Klass.periapsis = Klass.c;
	Klass.perhelion = Klass.c;
	Klass.pericenter = Klass.c;

	// state vectors at epoch time
	Klass.position = Klass.r;
	Klass.velocity = Klass.v;

	/*############################################################################*/
	// END OF AstroJS Orbit Module
	/*############################################################################*/

	exports.Orbit = exports.Orbital = Orbit;

})(this);
;
/*############################################################################*/
// AstroJS Time Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/
// Implementation is mostly one to one from libnova
// http://libnova.sourceforge.net/group__sidereal.html
// http://libnova.sourceforge.net/group__dynamical.html
// http://libnova.sourceforge.net/group__heliocentric.html
// http://libnova.sourceforge.net/group__nutation.html
/*############################################################################*/
'use strict';

(function (exports)
{

	/*############################################################################*/
	// constant factors for calculations
	/*############################################################################*/

	// dynamical time offset in seconds for
	// every second year from 1620 to 1992
	var delta_t = [
		124.0, 115.0, 106.0, 98.0, 91.0,
		85.0, 79.0, 74.0, 70.0, 65.0,
		62.0, 58.0, 55.0, 53.0, 50.0,
		48.0, 46.0, 44.0, 42.0, 40.0,
		37.0, 35.0, 33.0, 31.0, 28.0,
		26.0, 24.0, 22.0, 20.0, 18.0,
		16.0, 14.0, 13.0, 12.0, 11.0,
		10.0, 9.0, 9.0, 9.0, 9.0,
		9.0, 9.0, 9.0, 9.0, 10.0,
		10.0, 10.0, 10.0, 10.0, 11.0,
		11.0, 11.0, 11.0, 11.0, 11.0,
		11.0, 12.0, 12.0, 12.0, 12.0,
		12.0, 12.0, 13.0, 13.0, 13.0,
		13.0, 14.0, 14.0, 14.0, 15.0,
		15.0, 15.0, 15.0, 16.0, 16.0,
		16.0, 16.0, 16.0, 17.0, 17.0,
		17.0, 17.0, 17.0, 17.0, 17.0,
		17.0, 16.0, 16.0, 15.0, 14.0,
		13.7, 13.1, 12.7, 12.5, 12.5,
		12.5, 12.5, 12.5, 12.5, 12.3,
		12.0, 11.4, 10.6, 9.6, 8.6,
		7.5, 6.6, 6.0, 5.7, 5.6,
		5.7, 5.9, 6.2, 6.5, 6.8,
		7.1, 7.3, 7.5, 7.7, 7.8,
		7.9, 7.5, 6.4, 5.4, 2.9,
		1.6, -1.0, -2.7, -3.6, -4.7,
		-5.4, -5.2, -5.5, -5.6, -5.8,
		-5.9, -6.2, -6.4, -6.1, -4.7,
		-2.7, 0.0, 2.6, 5.4, 7.7,
		10.5, 13.4, 16.0, 18.2, 20.2,
		21.2, 22.4, 23.5, 23.9, 24.3,
		24.0, 23.9, 23.9, 23.7, 24.0,
		24.3, 25.3, 26.2, 27.3, 28.2,
		29.1, 30.0, 30.7, 31.4, 32.2,
		33.1, 34.0, 35.0, 36.5, 38.3,
		40.2, 42.2, 44.5, 46.5, 48.5,
		50.5, 52.2, 53.8, 54.9, 55.8,
		56.9, 58.3
	];

	// arguments and coefficients taken from table 21A on page 133
	var nut_args = [
		[ 0.0,  0.0,  0.0,  0.0,  1.0], [-2.0,  0.0,  0.0,  2.0,  2.0], [ 0.0,  0.0,  0.0,  2.0,  2.0],
		[ 0.0,  0.0,  0.0,  0.0,  2.0], [ 0.0,  1.0,  0.0,  0.0,  0.0], [ 0.0,  0.0,  1.0,  0.0,  0.0],
		[-2.0,  1.0,  0.0,  2.0,  2.0], [ 0.0,  0.0,  0.0,  2.0,  1.0], [ 0.0,  0.0,  1.0,  2.0,  2.0],
		[-2.0, -1.0,  0.0,  2.0,  2.0], [-2.0,  0.0,  1.0,  0.0,  0.0], [-2.0,  0.0,  0.0,  2.0,  1.0],
		[ 0.0,  0.0, -1.0,  2.0,  2.0], [ 2.0,  0.0,  0.0,  0.0,  0.0], [ 0.0,  0.0,  1.0,  0.0,  1.0],
		[ 2.0,  0.0, -1.0,  2.0,  2.0], [ 0.0,  0.0, -1.0,  0.0,  1.0], [ 0.0,  0.0,  1.0,  2.0,  1.0],
		[-2.0,  0.0,  2.0,  0.0,  0.0], [ 0.0,  0.0, -2.0,  2.0,  1.0], [ 2.0,  0.0,  0.0,  2.0,  2.0],
		[ 0.0,  0.0,  2.0,  2.0,  2.0], [ 0.0,  0.0,  2.0,  0.0,  0.0], [-2.0,  0.0,  1.0,  2.0,  2.0],
		[ 0.0,  0.0,  0.0,  2.0,  0.0], [-2.0,  0.0,  0.0,  2.0,  0.0], [ 0.0,  0.0, -1.0,  2.0,  1.0],
		[ 0.0,  2.0,  0.0,  0.0,  0.0], [ 2.0,  0.0, -1.0,  0.0,  1.0], [-2.0,  2.0,  0.0,  2.0,  2.0],
		[ 0.0,  1.0,  0.0,  0.0,  1.0], [-2.0,  0.0,  1.0,  0.0,  1.0], [ 0.0, -1.0,  0.0,  0.0,  1.0],
		[ 0.0,  0.0,  2.0, -2.0,  0.0], [ 2.0,  0.0, -1.0,  2.0,  1.0], [ 2.0,  0.0,  1.0,  2.0,  2.0],
		[ 0.0,  1.0,  0.0,  2.0,  2.0], [-2.0,  1.0,  1.0,  0.0,  0.0], [ 0.0, -1.0,  0.0,  2.0,  2.0],
		[ 2.0,  0.0,  0.0,  2.0,  1.0], [ 2.0,  0.0,  1.0,  0.0,  0.0], [-2.0,  0.0,  2.0,  2.0,  2.0],
		[-2.0,  0.0,  1.0,  2.0,  1.0], [ 2.0,  0.0, -2.0,  0.0,  1.0], [ 2.0,  0.0,  0.0,  0.0,  1.0],
		[ 0.0, -1.0,  1.0,  0.0,  0.0], [-2.0, -1.0,  0.0,  2.0,  1.0], [-2.0,  0.0,  0.0,  0.0,  1.0],
		[ 0.0,  0.0,  2.0,  2.0,  1.0], [-2.0,  0.0,  2.0,  0.0,  1.0], [-2.0,  1.0,  0.0,  2.0,  1.0],
		[ 0.0,  0.0,  1.0, -2.0,  0.0], [-1.0,  0.0,  1.0,  0.0,  0.0], [-2.0,  1.0,  0.0,  0.0,  0.0],
		[ 1.0,  0.0,  0.0,  0.0,  0.0], [ 0.0,  0.0,  1.0,  2.0,  0.0], [ 0.0,  0.0, -2.0,  2.0,  2.0],
		[-1.0, -1.0,  1.0,  0.0,  0.0], [ 0.0,  1.0,  1.0,  0.0,  0.0], [ 0.0, -1.0,  1.0,  2.0,  2.0],
		[ 2.0, -1.0, -1.0,  2.0,  2.0], [ 0.0,  0.0,  3.0,  2.0,  2.0], [ 2.0, -1.0,  0.0,  2.0,  2.0]
	];
	var nut_coeffs = [
		[-171996.0, -174.2, 92025.0,8.9], [-13187.0, -1.6, 5736.0, -3.1], [-2274.0, -0.2, 977.0, -0.5],
		[2062.0,   0.2,-895.0,  0.5], [1426.0,  -3.4,  54.0,  -0.1], [ 712.0,   0.1,  -7.0,   0.0],
		[-517.0,   1.2, 224.0, -0.6], [-386.0,  -0.4, 200.0,   0.0], [-301.0,   0.0, 129.0,  -0.1],
		[ 217.0, - 0.5, -95.0,  0.3], [-158.0,   0.0,   0.0,   0.0], [ 129.0,   0.1, -70.0,   0.0],
		[ 123.0,   0.0, -53.0,  0.0], [  63.0,   0.0,   0.0,   0.0], [  63.0,   0.1, -33.0,   0.0],
		[ -59.0,   0.0,  26.0,  0.0], [ -58.0,  -0.1,  32.0,   0.0], [ -51.0,   0.0,  27.0,   0.0],
		[  48.0,   0.0,   0.0,  0.0], [  46.0,   0.0, -24.0,   0.0], [ -38.0,   0.0,  16.0,   0.0],
		[ -31.0,   0.0,  13.0,  0.0], [  29.0,   0.0,   0.0,   0.0], [  29.0,   0.0, -12.0,   0.0],
		[  26.0,   0.0,   0.0,  0.0], [ -22.0,   0.0,   0.0,   0.0], [  21.0,   0.0, -10.0,   0.0],
		[  17.0, - 0.1,   0.0,  0.0], [  16.0,   0.0,  -8.0,   0.0], [ -16.0,   0.1,   7.0,   0.0],
		[ -15.0,   0.0,   9.0,  0.0], [ -13.0,   0.0,   7.0,   0.0], [ -12.0,   0.0,   6.0,   0.0],
		[  11.0,   0.0,   0.0,  0.0], [ -10.0,   0.0,   5.0,   0.0], [  -8.0,   0.0,   3.0,   0.0],
		[   7.0,   0.0,  -3.0,  0.0], [  -7.0,   0.0,   0.0,   0.0], [  -7.0,   0.0,   3.0,   0.0],
		[  -7.0,   0.0,   3.0,  0.0], [   6.0,   0.0,   0.0,   0.0], [   6.0,   0.0,  -3.0,   0.0],
		[   6.0,   0.0,  -3.0,  0.0], [  -6.0,   0.0,   3.0,   0.0], [  -6.0,   0.0,   3.0,   0.0],
		[   5.0,   0.0,   0.0,  0.0], [  -5.0,   0.0,   3.0,   0.0], [  -5.0,   0.0,   3.0,   0.0],
		[  -5.0,   0.0,   3.0,  0.0], [   4.0,   0.0,   0.0,   0.0], [   4.0,   0.0,   0.0,   0.0],
		[   4.0,   0.0,   0.0,  0.0], [  -4.0,   0.0,   0.0,   0.0], [  -4.0,   0.0,   0.0,   0.0],
		[  -4.0,   0.0,   0.0,  0.0], [   3.0,   0.0,   0.0,   0.0], [  -3.0,   0.0,   0.0,   0.0],
		[  -3.0,   0.0,   0.0,  0.0], [  -3.0,   0.0,   0.0,   0.0], [  -3.0,   0.0,   0.0,   0.0],
		[  -3.0,   0.0,   0.0,  0.0], [  -3.0,   0.0,   0.0,   0.0], [  -3.0,   0.0,   0.0,   0.0]
	];

	/*############################################################################*/
	// return nutation parameters on given julian days
	/*############################################################################*/

	var FD0 = 297.85036 * DEG2RAD, FD1 = 445267.111480 * DEG2RAD, FD2 = - 0.0019142 * DEG2RAD, FD3 = DEG2RAD / 189474.0,
	    FM0 = 357.52772 * DEG2RAD, FM1 = 35999.050340 * DEG2RAD, FM2 = - 0.0086972 * DEG2RAD, FM3 = - DEG2RAD / 300000.0,
	    FMM0 = 134.96298 * DEG2RAD, FMM1 = 477198.867398 * DEG2RAD, FMM2 = 0.0086972 * DEG2RAD, FMM3 = DEG2RAD / 56250.0,
	    FF0 = 93.2719100 * DEG2RAD, FF1 = 483202.017538 * DEG2RAD, FF2 = - 0.0036825 * DEG2RAD, FF3 = DEG2RAD / 327270.0,
	    FO0 = 125.04452 * DEG2RAD, FO1 = - 1934.136261 * DEG2RAD, FO2 = 0.0020708 * DEG2RAD, FO3 = DEG2RAD / 450000.0;

	function getNutation(JD)
	{

		// should we bother recalculating nutation (caching)
		// if (fabs(JD - c_JD) > EPOCH_THRESHOLD) {
		// set the new epoch //
		// c_JD = JD;

		// get julian ephemeris day
		var JDE = JD2toJDE(JD);

		// calc T and dependants
		var T = JDtoJY2K(JDE) / 100,
		    T2 = T * T, T3 = T2 * T;

		// calculate D,M,M',F and Omega (convert to radians)
		var D = FD0 + FD1 * T + FD2 * T2 + FD3 * T3;
		var M = FM0 + FM1 * T + FM2 * T2 + FM3 * T3;
		var MM = FMM0 + FMM1 * T + FMM2 * T2 + FMM3 * T3;
		var F = FF0 + FF1 * T + FF2 * T2 + FF3 * T3;
		var O = FO0 + FO1 * T + FO2 * T2 + FO3 * T3;

		// init variables for coeff sums
		// get accumulated in for loop
		var c_longitude = 0, c_obliquity = 0;
		var coeff_sine, coeff_cos, arg;

		// calc sum of terms in table 21A
		for (var i = 0; i < nut_coeffs.length; i++) {
			// calc coefficients of sine and cosine
			coeff_sine = (nut_coeffs[i][0] +
				(nut_coeffs[i][1] * T));
			coeff_cos = (nut_coeffs[i][2] +
				(nut_coeffs[i][3] * T));
			// calculate main argument
			arg = nut_args[i][0] * D
			    + nut_args[i][1] * M
			    + nut_args[i][2] * MM
			    + nut_args[i][3] * F
			    + nut_args[i][4] * O;
			// sum up oscillating elements
			c_longitude += coeff_sine * Math.sin(arg);
			c_obliquity += coeff_cos * Math.cos(arg);
		}

		// c_longitude /= 100000.0;
		// c_obliquity /= 100000.0;

		// calculate mean ecliptic - Meeus 2nd edition, eq. 22.2
		var c_ecliptic = 23.0 + 26.0 / 60.0 + 21.448 / 3600.0
		               - 46.81500 / 3600.0 * T
		               - 0.000590 / 3600.0 * T2
		               + 0.001813 / 3600.0 * T3;

		// change to radiants
		c_ecliptic *= DEG2RAD;
		// use special conversion factor
		// change time (hours?) to to arcsecs
		c_longitude /= 3600 * 100 * 100 / DEG2RAD;
		c_obliquity /= 3600 * 100 * 100 / DEG2RAD;

		// Uncomment this if function should return
		// true obliquity rather than mean obliquity
		/* c_ecliptic += c_obliquity; */

		// } // caching

		// return results
		return {
			longitude: TURN(c_longitude), // verified
			obliquity: TURN(c_obliquity), // verified
			ecliptic: CYCLE(c_ecliptic) // unverified
		}

	}
	// EO nutation

	// Stephenson and Houlden for years prior to 948 A.D.
	function getDynamicalTimeDiffSH1(JD)
	{
		// number of centuries from 948
		var E = (JD - 2067314.5) / 36525.0;
		return 1830.0 - 405.0 * E + 46.5 * E * E;
	}

	// Stephenson and Houlden for years between 948 A.D. and 1600 A.D.
	function getDynamicalTimeDiffSH2(JD)
	{
		/* number of centuries from 1850 */
		var t = (JD - 2396758.5) / 36525.0;
		return 22.5 * t * t;
	}

	// Table 9.a pg 72 for years 1600..1992
	// uses interpolation formula 3.3 on pg 25
	function getDynamicalTimeDiffTable(JD)
	{
		// get no days since 1620 and divide by 2 years
		var i = Math.floor((JD - 2312752.5) / 730.5);
		// get the base interpolation factor in the table
		if (i > (delta_t.length - 2)) i = delta_t.length - 2;
		// calculate a, b, c, n
		var a = delta_t[i+1] - delta_t[i], b = delta_t[i+2] - delta_t[i+1],
		    c = a - b, n = ((JD - (2312752.5 + (730.5 * i))) / 730.5);
		return delta_t[i + 1] + n / 2 * (a + b + n * c);
	}

	// get the dynamical time diff in the near past / future 1992 .. 2010
	/// uses interpolation formula 3.3 on pg 25
	function getDynamicalTimeDiffNear(JD)
	{
		// TD for 1990, 2000, 2010
		var delta_T = [ 56.86, 63.83, 70.0 ];
		// calculate TD by interpolating value
		var a = delta_T[1] - delta_T[0],
		    b = delta_T[2] - delta_T[1],
		    c = b - a;
		// get number of days since 2000 and divide by 10 years
		var n = (JD - 2451544.5) / 3652.5;
		return delta_T[1] + (n / 2) * (a + b + n * c);
	}

	// uses equation 9.1 pg 73 to calc JDE for other JD values
	function getDynamicalTimeDiffElse(JD)
	{
		var a = (JD - 2382148.0);
		return -15.0 + a * a / 41048480.0;
	}

	// Calculates the dynamical time (TD) difference in seconds
	// (delta T) from universal time. Equation 9.1 on pg 73.
	// check when JD is, and use corresponding formula
	function getDynamicalTimeDiff(JD)
	{
		// check for date < 948 A.D.
		if (JD < 2067314.5) {
			// Stephenson and Houlden
			return getDynamicalTimeDiffSH1(JD);
		}
		// check for date 948..1600 A.D.
		else if (JD >= 2067314.5 && JD < 2305447.5) {
			// Stephenson and Houlden
			return getDynamicalTimeDiffSH2(JD);
		}
		// check for value in table 1620..1992
		else if (JD >= 2312752.5 && JD < 2448622.5) {
			// interpolation of table
			return getDynamicalTimeDiffTable(JD);
		}
		// check for near future 1992..2010
		else if (JD >= 2448622.5 && JD <= 2455197.5) {
			// use value interpolation
			return getDynamicalTimeDiffNear(JD);
		}
		// other time period (outside)
		return getDynamicalTimeDiffElse(JD);
	}

	// Calculates the Julian Ephemeris Day(JDE)
	function JDtoJDE(JD)
	{
		// from the given Julian Day (JD)
		return JD + getDynamicalTimeDiff(JD) / JD2SEC;
	}

	// Calculates the Julian Day(JDE)
	function JDEtoJD(JDE)
	{
		// from the given Julian Ephemeris Day (JD)
		return JDE - getDynamicalTimeDiff(JDE) / JD2SEC;
	}

	/*############################################################################*/
	// Sidereal time calculations
	/*############################################################################*/

	// factors for sidereal time offset
	var FST1 = 280.46061837 * DEG2RAD,
	    FST2 = 360.98564736629 * DEG2RAD,
	    FST3 = 0.000387933 * DEG2RAD,
	    FST4 = - DEG2RAD / 38710000.0,
	    // ratio longitude nutation
	    FLON = 1; // 15.0 * DEG2HMS;

	// returns rad (you want HMS?)
	function getMeanSiderealTime(JD)
	{
		var T = JDtoJY2K(JD) / 100;
		// calculate mean angle (in radians)
		var sidereal = FST1 + FST2 *(JD - 2451545.0)
			           + FST3 * T * T + FST4 * T * T * T;
		// clamp to valid range
		return CYCLE(sidereal);
	}

	// returns rad (you want HMS?)
	function getApparentSiderealTime(JD)
	{
		// get nutation parameters
		var nutation = getNutation(JD);
		// get the mean sidereal time and add
		return getMeanSiderealTime(JD) +
			// add corrections for nutation in longitude
			// and for the true obliquity o the ecliptic
			nutation.longitude / FLON *
			Math.cos(nutation.obliquity);
	}

	/*############################################################################*/
	// END OF AstroJS Time Module
	/*############################################################################*/

	// date converter
	exports.JDtoJDE = JDtoJDE;
	exports.JDEtoJD = JDEtoJD;

	// sidereal time calculations
	exports.getMeanSiderealTime = getMeanSiderealTime;
	exports.getApparentSiderealTime = getApparentSiderealTime;

	// calculate earth nutations
	exports.getNutation = getNutation;

})(this);
;
/*############################################################################*/
// AstroJS Coordinate Module (c) 2016 by Marcel Greter
// https://www.github.com/mgreter/astrojs/LICENSE
/*############################################################################*/
// https://en.wikipedia.org/wiki/Cartesian_coordinate_system (xyz)
// https://en.wikipedia.org/wiki/Spherical_coordinate_system (lbr)
// https://en.wikipedia.org/wiki/Cylindrical_coordinate_system (zlp)
/*############################################################################*/
'use strict';

(function (exports) {

	/*############################################################################*/
	// private converter and helper functions
	/*############################################################################*/

	// getter functions for calculated coordinates
	function cyl() { return { p: this.p, l: this.l, z: this.z }; }
	function cart() { return { x: this.x, y: this.y, z: this.z }; }
	function sph() { return { l: this.l, b: this.b, i: this.i, r: this.r }; }

	/*############################################################################*/
	// These functions act as auto-loaders. They will convert the
	// coordinates once and then replace the getter function.
	/*############################################################################*/

	// Cartesian to Spherical
	function cart2sph()
	{
		this.r = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
		this.i = Math.acos(this.z / this.r), this.b = PI/2 - this.i;
		this.l = Math.atan2(this.y, this.x);
		return (this.sph = sph).call(this);
	}

	// Spherical to Cartesian
	function sph2cart()
	{
		var rsb = this.r * Math.sin(this.i);
		// var rsb = this.r * Math.cos(this.b);
		this.x = rsb * Math.cos(this.l);
		this.y = rsb * Math.sin(this.l);
		this.z = this.r * Math.cos(this.i);
		return (this.cart = cart).call(this);
	}

	// Cartesian to Cylindrical
	function cart2cyl()
	{
		this.p = Math.sqrt(this.x*this.x + this.y*this.y);
		this.l = Math.atan2(this.y, this.x);
		return (this.cyl = cyl).call(this);
	}

	// Cylindrical to Cartesian
	function cyl2cart()
	{
		this.x = this.p * Math.cos(this.l);
		this.y = this.p * Math.sin(this.l);
		return (this.cart = cart).call(this);
	}

	// Cylindrical to Spherical
	function cyl2sph()
	{
		this.i = Math.atan2(this.p, this.z), this.b = PI/2 - this.i;
		this.r = Math.sqrt(this.p*this.p + this.z*this.z);
		return (this.sph = sph).call(this);
	}

	// Spherical to Cylindrical
	function sph2cyl()
	{
		this.p = this.r * Math.cos(this.b);
		this.z = this.r * Math.sin(this.b);
		return (this.cyl = cyl).call(this);
	}

	/*############################################################################*/
	// Class Constructor for Coordinate
	/*############################################################################*/

	/******************************************************************************/
	// Coordinate supports conversion between Cartesian, Spherical
	// and Cylindrical Coordinates. Use either for the constructor.
	/******************************************************************************/
	function Coord(state)
	{
		// allow input also in some other form
		if ('ra' in state) state.l = state.ra;
		if ('dec' in state) state.b = state.dec;
		if ('dist' in state) state.r = state.dist;
		// from Cartesian coordinates
		if ('x' in state && 'y' in state && 'z' in state) {
			this.x = state.x, this.y = state.y, this.z = state.z;
			this.cart = cart, this.sph = cart2sph, this.cyl = cart2cyl;
		}
		// from Cylindrical coordinates
		else if ('p' in state && 'l' in state && 'z' in state) {
			this.p = state.p, this.l = state.l, this.z = state.z;
			this.cart = cyl2cart, this.sph = cyl2sph, this.cyl = cyl;
		}
		// from Spherical coordinates
		else if ('l' in state /* && 'r' in state */) {
			// store given parameters, then ...
			this.l = state.l, this.r = state.r || 1;
			// ... inclination or elevation
			if ('i' in state || 'b' in state) {
				this.cart = sph2cart, this.sph = sph, this.cyl = sph2cyl;
				if ('b' in state) this.b = state.b, this.i = PI/2 - this.b;
				else if ('i' in state) this.i = state.i, this.b = PI/2 - this.i;
			}
		}
	}

	/*############################################################################*/
	// conversion between various formats
	/*############################################################################*/
	// Equatorial - declination (d) and hour angle (h)
	//            - declination (d) and right ascension (a)
	// Ecliptic - ecliptic latitude () and ecliptic longitude (?)
	// Galactic - galactic latitude (b) and galactic longitude (l)
	// Observer - altitude (a) or elevation and azimuth (A)
	// Note: VSOP87 coordinates are heliocentric ecliptic
	/*############################################################################*/
	// ecliptic to equatorial (compensate axial tilt)
	// equatorial to galactic (compensate precession)
	/*############################################################################*/
	// Mean equinox of date: Equator rotated by precession to its position
	// at "date", but free from the small periodic oscillations of nutation
	// True equinox of date: This is the actual intersection of the two
	// planes at any particular moment, with all motions accounted for.
	/*############################################################################*/

	// ecliptic to equatorial coordinates
	// pass obliquity of ecliptic (axial tilt)
	Coord.prototype.ecl2equ = function ecl2equ(tilt)
	{
		// convert via Cartesian
		var cart = this.cart(),
		    sin_e = Math.sin(tilt),
		    cos_e = Math.cos(tilt);
		// return new coordinate
		return new Coord({
			x: cart.x,
			y: cart.y * cos_e - cart.z * sin_e,
			z: cart.z * cos_e + cart.y * sin_e,
		});
	}

	// equatorial to ecliptic coordinates
	// pass obliquity of ecliptic (axial tilt)
	Coord.prototype.equ2ecl = function equ2ecl(tilt)
	{
		// convert via Cartesian
		var cart = this.cart(),
		    sin_e = Math.sin(tilt),
		    cos_e = Math.cos(tilt);
		// return new coordinate
		return new Coord({
			x: cart.x,
			y: cart.y * cos_e + cart.z * sin_e,
			z: cart.z * cos_e - cart.y * sin_e,
		});
	}

	var posangle = 32.932 * DEG2RAD;
	var pole_ra = 192.859508 * DEG2RAD;
	var pole_dec = 27.128336 * DEG2RAD;

	// North galactic pole (B1950)
	// var pole_ra = 192.25 * DEG2RAD;
	// var pole_dec = 27.4 * DEG2RAD;
	// var posangle = 33.0 * DEG2RAD;

	// galactic to equatorial coordinates
	// equatorial coordinate has only l/b
	Coord.prototype.gal2equ = function gal2equ()
	{
		// pre-calculations
		var sph = this.sph(),
		    l = sph.l, b = sph.b,
		    sin_b = Math.sin(b),
		    cos_b = Math.cos(b),
		    sin_pdc = Math.sin(pole_dec),
		    cos_pdc = Math.cos(pole_dec),
		    sin_pos = Math.sin(l - posangle),
		    cos_pos = Math.cos(l - posangle),
		    sincos_bp = cos_b * sin_pos;
		// ToDo: compensate for precision if epoch differs
		// to galactic coordinates after precession compensated
		var B = Math.asin( sin_b * sin_pdc + sincos_bp * cos_pdc );
		var L = Math.atan2(cos_b * cos_pos, sin_b * cos_pdc - sincos_bp * sin_pdc);
		// return object in valid range
		// ToDo: should `b` be half turn?
		return { l: CYCLE(L + pole_ra), b: TURN(B) };
	}

	// equatorial to galactic coordinates
	// gallactic coordinate has only l/b
	Coord.prototype.equ2gal = function equ2gal()
	{
		// pre-calculations
		var sph = this.sph(),
		    l = sph.l, b = sph.b,
		    sin_b = Math.sin(b),
		    cos_b = Math.cos(b),
		    tan_b = sin_b / cos_b,
		    sin_pdc = Math.sin(pole_dec),
		    cos_pdc = Math.cos(pole_dec),
		    sin_pos = Math.sin(pole_ra - l),
		    cos_pos = Math.cos(pole_ra - l),
		    sincos_bp = cos_b * sin_pos;
		// ToDo: compensate for precision if epoch differs
		// to equatorial coordinates after precession compensated
		var B = Math.asin( sin_b * sin_pdc + cos_b * cos_pdc * cos_pos );
		var L = Math.atan2( sin_pos, cos_pos * sin_pdc - tan_b * cos_pdc);
		// return object in valid range
		// ToDo: should `b` be half turn?
		return { l: CYCLE(posangle - L - PI/2), b: TURN(B) };
	}

	/*############################################################################*/
	// Precession to convert from the international terrestrial reference
	// system (ITRF) to the international celestial reference frame (ICRF)
	/*############################################################################*/

	// precession factors for J2000 frame
	var PFA = 2306.2181*DEG2RAD, PFB = 1.39656*DEG2RAD, PFC = 0.000139*DEG2RAD,
	    PFD = 0.30188*DEG2RAD, PFE = 0.000344*DEG2RAD, PFF = 0.017998*DEG2RAD,
	    PFG = 1.09468*DEG2RAD, PFH = 0.000066*DEG2RAD, PFI = 0.018203*DEG2RAD,
	    PFJ = 2004.3109*DEG2RAD, PFK = 0.85330*DEG2RAD, PFL = 0.000217*DEG2RAD,
	    PFM = 0.42665*DEG2RAD, PFN = 0.000217*DEG2RAD, PFP = 0.041833*DEG2RAD;

	Coord.prototype.precess = function precess(JD, epoch)
	{
		// Change original ra and dec to radians
		var mean_ra = this.l, mean_dec = this.b;
		// calc t, zeta, eta and theta for J2000.0 Equ 20.3
		var eta, zeta, theta, T, T2,
		    t = (JD - epoch) / 360000.0,
		    t2 = t * t, t3 = t2 *t;
		// optimize for epoch == 0
		if (t) {
			T = epoch / 360000.0, T2 = T * T;
			eta = (PFA + PFB * T - PFC * T2) * t
			     + (PFG + PFH * T) * t2 + PFI * t3;
			zeta = (PFA + PFB * T - PFC * T2) * t
			     + (PFD - PFE * T) * t2 + PFF * t3;
			theta = (PFJ - PFK * T - PFN * T2) * t
				    - (PFM + PFN * T) * t2 - PFP * t3;
		}
		else {
			eta = PFA * t + PFG * t2 + PFP * t3;
			zeta = PFA * t + PFD * t2 + PFF * t3;
			theta = PFJ * t - PFN * t2 - PFP * t3;
		}

		// calc A,B,C equ 20.4
		var sin_md = Math.sin(mean_dec), cos_md = Math.cos(mean_dec),
		    mean_term = cos_md * Math.cos(mean_ra + zeta),
		    A = cos_md * Math.sin(mean_ra + zeta),
		    B = Math.cos(theta) * mean_term - Math.sin(theta) * Math.sin(mean_dec),
		    C = Math.sin (theta) * mean_term + Math.cos(theta) * Math.sin(mean_dec);

		// calculate right ascension
		var ra = Math.atan2(A, B) + eta, dec;

		// check for object near celestial pole
		if (mean_dec > (0.4 * PI) || mean_dec < (-0.4 * PI)) {
			// close to pole (better precision)
			dec = Math.acos(Math.sqrt(A * A + B * B));
			// check 0 <= acos() <= PI
			if (mean_dec < 0.) { dec *= -1;  }
		}
		// not close to pole
		else { dec = Math.asin(C); }

		// return object in valid range
		// ToDo: should `b` be half turn?
		var coord = { l: CYCLE(ra), b: TURN(dec) };
		if ('r' in this) coord.r = this.r;
		return coord;
	}

	/*############################################################################*/
	// END OF AstroJS Coordinate Module
	/*############################################################################*/

	exports.Coord = Coord;

})(this);
;
}).call(this, this)
/* crc: 261C6A7AD7438A8E387F065EFDEDD7F2 */

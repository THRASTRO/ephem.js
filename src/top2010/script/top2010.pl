################################################################################
# AstroJS TOP2010 converter script (c) 2016 by Marcel Greter
################################################################################
# Very quick and dirty perl script to get the job done.
################################################################################
use strict;
use warnings;

use JSON qw();
use File::Path;
use File::Slurp;

our $accuracy = 10e-6;
unless(defined $ARGV[0]) {
	warn "using default precision of 10e-6\n";
} else {
	$accuracy = $ARGV[0];
}

our $target = 'src';
if(defined $ARGV[1]) {
	$target = $ARGV[1];
	if (!-d $target && !File::Path::make_path($target)) {
		warn "could not create $target\n";
	}
}

# TOP2010 Masses system (DE405) -> au and julian years
my $rmu = [
	# not sure if it is correct to add the planet mass here
	# convert from julian days to julian years (Math.pow(365.25, 2))
	(0.2959122082855911e-03 + 0.4912547451450812e-10) * 133407.5625,
	(0.2959122082855911e-03 + 0.7243452486162703e-09) * 133407.5625,
	(0.2959122082855911e-03 + 0.8997011346712499e-09) * 133407.5625,
	(0.2959122082855911e-03 + 0.9549535105779258e-10) * 133407.5625,
	(0.2959122082855911e-03 + 0.2825345909524226e-06) * 133407.5625,
	(0.2959122082855911e-03 + 0.8459715185680659e-07) * 133407.5625,
	(0.2959122082855911e-03 + 0.1292024916781969e-07) * 133407.5625,
	(0.2959122082855911e-03 + 0.1524358900784276e-07) * 133407.5625,
	(0.2959122082855911e-03 + 0.2188699765425970e-11) * 133407.5625,
];

############################################################
# main generate functions
############################################################

sub gen_top2k_get_coeff_sum
{

	my ($coeff, $pow, $acc2) = @_;
	my @coeffs;
	return \@coeffs unless $coeff;
	for (my $i = 0; $i < scalar(@{$coeff}); $i++) {

		my @phis;
		my $factors = $coeff->[$i];
		my $S = $factors->[1] * 10 ** $factors->[2];
		my $C = $factors->[3] * 10 ** $factors->[4];
		next if ($i > ($pow ? -1 : 2) && $S**2 + $C**2 < $acc2);
		push @coeffs, $factors->[0], $factors->[1] . 'e' . $factors->[2],
			$factors->[3] . 'e' . $factors->[4], $factors->[5] ? $factors->[5] : 0;

	}
	return \@coeffs;
}

use Data::Dumper;

sub gen_top2k_get_coeffs
{
	my ($coeffs, $acc2) = @_;
	my @names = ("a", "L", "k", "h", "q", "p");
	my @coeffs;
	for (my $w = 0; $w < scalar(@names); $w ++) {
		my @rawcoeffs;
		for (my $i = 0; $i < scalar(@{$coeffs->[$w]}); $i ++) {
			push @rawcoeffs, gen_top2k_get_coeff_sum($coeffs->[$w]->[$i], $i, $acc2);
 		}
		push @coeffs, \@rawcoeffs;
	}

	return \@coeffs;
}

my @top2k;

sub gen_top2k
{

	my ($factors);
	my ($body, $part, $acc) = @_;
	my $float = qr/[-+]?(?:[.]\d+|\d+(?:[.]\d*)?)/;

	my $theory = substr($body, 0, 3);
	my $name = sprintf("top2010_%s", $theory);

	# only read in once
	if (scalar(@top2k) == 0) {

		# open input data file and read by line
		my $file = sprintf "data/TOP2010.dat";
		open(my $fh, "<", $file) or die "could not open $file\n$!";

		# parse top2010 data file by lines
		while (defined(my $line = <$fh>))
		{
			next if $line =~ m/^\s*$/;
			if ($line =~ m/^\s*TOP201[03]ELL\s+PLANET\s+(\d+)\s+VARIABLE\s+(\d+)\s+T\*\*(\d+)\s+(\d+)\s+term\(s\)/) {
				my ($v, $obj, $var, $exp) = ($3, $1, $2, $3);
				$top2k[$obj - 1][$var - 1][$exp] = $factors = [];
			} elsif ($line =~ m/^\s*TOP201[03]/) {
				warn "unrecocnised line:\n$line\n";
			} else {
				my @coeffs = (
					substr($line, 0, 9),
					substr($line, 9, 22),
					substr($line, 31, 4),
					substr($line, 35, 22),
					substr($line, 57, 4),
					substr($line, 61, 22),
				);
				$coeffs[5] = 0 if ($coeffs[5] =~ m/^\s*$/);
				@coeffs = map { $_ = $_ * 1.0;
					warn $line unless m/^\s*$float\s*$/;
					die "no number $_" unless m/^\s*$float\s*$/;
					$_ + 0
				} @coeffs;
				warn "invalid factors?".join(", ", @coeffs) if scalar(@coeffs) != 6 && scalar(@coeffs) != 5;
				push @{$factors}, \@coeffs;
			}
		}

	}

	# create json exporter
	my $json = new JSON;
	# sort keys in objects
	$json->canonical(1);

	# create the javascript code
	my $code = "// generated by top2010.pl\n";

	# add the frequencies for top2010 theory
	$code .= "var freq = [0.5296909690160131e+03, 0.2132990807324141e+03, 0.7478165810226641e+02, 0.3813292747646720e+02, 0.2533634111740826e+02];\n";

	# get the filtered coefficients
	die  "has no part" unless $top2k[$part - 1];
	my $coeffs = gen_top2k_get_coeffs($top2k[$part - 1], $acc*$acc);
	# export coefficients to json
	my $js =  $json->encode($coeffs);

	# unwrap concated numbers
	$js =~ s/\"//gm;

	# write the exporting line into the code
	$code .= "top2010.${theory} = TOP2K('${theory}', $rmu->[$part-1], ${js}, $part - 1, freq);\n";

	# write the final javascript file
	write_file "$target/$name.js", $code;

}

############################################################
# Main program to generate all theories starts here
############################################################

my @planets = (
	["jupiter", 5, $accuracy],
	["saturn", 6, $accuracy],
	["uranus", 7, $accuracy],
	["neptune", 8, $accuracy],
	["pluto", 9, $accuracy]
);

for my $planet (@planets) {
	printf "create %s\n",
		$planet->[0];
	gen_top2k(@{$planet});
}

############################################################
# Create the unit test file
############################################################
my %qidmap = (2 => 0, 4 => 1, 6 => 2, 8 => 3, 10 => 4, 12 => 5);
if ($target =~ m/^src[\/\\](\d+)-(\w+)/) {
	my ($id, $qid, $qname) = ($1, $qidmap{$1+0}, $2);
	my $config = { binmode => ':raw' };
	my $tmpl = read_file( 'conf/unit-test.thtml', $config);
	die "could not read unit test template" unless $tmpl;
	my $path = sprintf('../../test/top2010/%02d-%s.html', $id, $qname);
	$tmpl =~ s/%%id%%/$qid/g; write_file($path, $config, $tmpl);
}

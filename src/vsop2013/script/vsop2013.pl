################################################################################
# AstroJS VSOP2013 converter script (c) 2016 by Marcel Greter
################################################################################
# Very quick and dirty perl script to get the job done.
################################################################################
use strict;
use warnings;

use JSON qw();
use File::Path;
use File::Slurp;

our $accuracy = 10e-6;
unless(defined $ARGV[0]) {
	warn "using default precision of 10e-6\n";
} else {
	$accuracy = $ARGV[0];
}

our $target = 'src';
if(defined $ARGV[1]) {
	$target = $ARGV[1];
	if (!-d $target && !File::Path::make_path($target)) {
		warn "could not create $target\n";
	}
}

# VSOP2013 Masses system (INPOP10A) -> au and julian years
my $rmu = [
	# not sure if it is correct to add the planet mass here
	# convert from julian days to julian years (Math.pow(365.25, 2))
	(2.9591220836841438269e-04 + 4.9125474514508118699e-11) * 133407.5625,
	(2.9591220836841438269e-04 + 7.2434524861627027000e-10) * 133407.5625,
	(2.9591220836841438269e-04 + 8.9970116036316091182e-10) * 133407.5625,
	(2.9591220836841438269e-04 + 9.5495351057792580598e-11) * 133407.5625,
	(2.9591220836841438269e-04 + 2.8253458420837780000e-07) * 133407.5625,
	(2.9591220836841438269e-04 + 8.4597151856806587398e-08) * 133407.5625,
	(2.9591220836841438269e-04 + 1.2920249167819693900e-08) * 133407.5625,
	(2.9591220836841438269e-04 + 1.5243589007842762800e-08) * 133407.5625,
	(2.9591220836841438269e-04 + 2.1886997654259696800e-12) * 133407.5625,
];

############################################################
# main generate functions
############################################################

sub gen_vsop2k_get_coeff_sum
{

	my ($coeff, $pow, $acc2) = @_;
	my @coeffs;
	for (my $i = 0; $i < scalar(@{$coeff}); $i++) {

		my @phis;
		my $factors = $coeff->[$i];
		my $S = $factors->[18] * 10**$factors->[19];
		my $C = $factors->[20] * 10**$factors->[21];
		next if ($i > ($pow ? -1 : 2) && $S**2 + $C**2 < $acc2);
		for (my $i = 1; $i <= 17; $i++) {
			if ($factors->[$i]) {
				push @phis, $i, $factors->[$i];
			}
		}
		push @coeffs, $S, $C, \@phis;
	}
	return \@coeffs;
}

sub gen_vsop2k_get_coeffs
{

	my ($coeffs, $acc2) = @_;
	my @names = ("a", "L", "k", "h", "q", "p");
	my %coeffs;
	for (my $w = 0; $w < scalar(@names); $w ++) {
		my @rawcoeffs;
		for (my $i = 0; $i < scalar(@{$coeffs->[$w]}); $i ++) {
			push @rawcoeffs, gen_vsop2k_get_coeff_sum($coeffs->[$w]->[$i], $i, $acc2);
		}
		pop @rawcoeffs while (scalar(@rawcoeffs) && $#{$rawcoeffs[-1]} == -1);
		$coeffs{$names[$w]} = \@rawcoeffs;
	}

	return \%coeffs;
}

sub gen_vsop2k
{

	my (@vsop2k, $factors);
	my ($body, $part, $acc) = @_;
	my $float = qr/[-+]?(?:[.]\d+|\d+(?:[.]\d*)?)/;

	# open input data file and read by line
	my $theory = substr($body, 0, 3);
	my $name = sprintf("vsop2013_%s", $theory);
	my $file = sprintf "data/VSOP2013p%d.dat", $part;
	open(my $fh, "<", $file) or die "could not open $file\n$!";

	# parse vsop2013 data file by lines
	while (defined(my $line = <$fh>))
	{
		if ($line =~ m/^\s*VSOP201[03]\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+([\w\-]+)\s+VARIABLE\s+\w+\s+\*+T\*+(\d+)/) {
			my ($v, $obj, $var, $exp) = ($3, $1, $2, $6);
			$vsop2k[$var - 1][$exp] = $factors = [];
		} elsif ($line =~ m/^\s*VSOP201[03]/) {
			warn "unrecocnised line:\n$line\n";
		} else {
			$line =~ s/\A\s+//;
			$line =~ s/\s+\z//;
			my @coeffs = map {
				warn $line unless m/^\s*$float\s*$/;
				die "no number $_" unless m/^\s*$float\s*$/;
				$_ + 0
			} split /(?:\s+|(?=-))/, $line;
			warn "invalid factors?" if scalar @coeffs != 22;
			push @{$factors}, \@coeffs;
		}
	}

	# create json exporter
	my $json = new JSON;
	# sort keys in objects
	$json->canonical(1);

	# create the javascript code
	my $code = "// generated by vsop2013.pl\n";

	# get the filtered coefficients
	my $coeffs = gen_vsop2k_get_coeffs(\@vsop2k, $acc*$acc);
	# export coefficients to json
	my $js = "{\n" . (join ",\n", map {
		sprintf "	%s: %s", $_ , $json->encode($coeffs->{$_})
	} sort keys %{$coeffs}) . "\n}";

	$code .= "vsop2013.${theory} = VSOP2K('${theory}', $rmu->[$part-1], ${js});\n";

	# write the final javascript file
	write_file "$target/$name.js", $code;

}

############################################################
# Main program to generate all theories starts here
############################################################

my @planets = (
	["mercury", 1, $accuracy],
	["venus", 2, $accuracy],
	["emb", 3, $accuracy],
	["mars", 4, $accuracy],
	["jupiter", 5, $accuracy],
	["saturn", 6, $accuracy],
	["uranus", 7, $accuracy],
	["neptune", 8, $accuracy],
	["pluto", 9, $accuracy]
);

for my $planet (@planets) {
	printf "create %s\n",
		$planet->[0];
	gen_vsop2k(@{$planet});
}

############################################################
# Create the unit test file
############################################################
my %qidmap = (2 => 0, 4 => 1, 6 => 2, 8 => 3, 10 => 4, 12 => 5);
if ($target =~ m/^src[\/\\](\d+)-(\w+)/) {
	my ($id, $qid, $qname) = ($1, $qidmap{$1+0}, $2);
	my $config = { binmode => ':raw' };
	my $tmpl = read_file( 'conf/unit-test.thtml', $config);
	die "could not read unit test template" unless $tmpl;
	my $path = sprintf('../../test/vsop2013/%02d-%s.html', $id, $qname);
	$tmpl =~ s/%%id%%/$qid/g; write_file($path, $config, $tmpl);
}

/* autogenerated by webmerge (join context) */
;
var vsop87b = {};
//***********************************************************
// (c) 2016 by Marcel Greter
// AstroJS VSOP87 utility lib
// https://github.com/mgreter/ephem.js
//***********************************************************
(function(exports) {

	var mat3; // allocate when needed

	// update vsop elements in elems at offset and return elems array
	function vsop(solver, theory, jy2k, elems, addGM, addEpoch, off)
	{
		off = off || 0;
		jy2k = jy2k || 0;
		elems = elems || [];
		// call main theory to fill elements
		solver(theory, jy2k, elems, addGM, addEpoch, off);
		// check if theory gives mean motion
		if (theory.givesMeanMotion) {
			// assume that mean motion is in days, convert to years
			var fact = elems[off+0] * theory.givesMeanMotion;
			// convert mean motion to semi-major axis via gravitational parameter
			elems[off+0] = Math.cbrt(theory.GM / fact / fact);
		}
		// a bit expensive to get as we need to
		// convert into cartesian to apply rotation
		// we then reconstruct the kepler elements
		// ToDo: can this be implemented directly?
		// Note: doesn't seem to be too obvious!?
		if (toVSOP = theory.toVSOP) {
			// translate via cartesian coords
			// there might be an easier way?
			// do we really need to convert?
			var orbit = new Orbit({
				a: elems[off+0],
				L: elems[off+1],
				k: elems[off+2],
				h: elems[off+3],
				q: elems[off+4],
				p: elems[off+5],
				GM: theory.GM,
				epoch: jy2k
			});
			// get state vectors
			var state = orbit.state(jy2k);
			// check for dynamic rotations
			if (typeof toVSOP == "function") {
				// create only once needed
				mat3 = mat3 || new THREE.Matrix3();
				// get dynamic matrix
				toVSOP(jy2k, mat3);
				toVSOP = mat3;
			}
			// rotate cartesian vectors
			state.r.applyMatrix3(toVSOP);
			state.v.applyMatrix3(toVSOP);
			// create via rotated state
			orbit = new Orbit(state);
			// update state elements
			elems[off++] = orbit._a;
			elems[off++] = orbit.L();
			elems[off++] = orbit.k();
			elems[off++] = orbit.h();
			elems[off++] = orbit.q();
			elems[off++] = orbit.p();
		}
		// return state object
		return elems;
	}
	// EO vsop

	// Return an orbital object suitable to create new Orbit
	function orbital(solver, theory, jy2k, elems, addGM, addEpoch, off)
	{
		off = off || 0;
		jy2k = jy2k || 0;
		elems = elems || [];
		// call main theory to fill elements
		vsop(solver, theory, jy2k, elems, addGM, addEpoch, off);
		// return orbital object
		return {
			a: elems[off++],
			L: elems[off++],
			k: elems[off++],
			h: elems[off++],
			q: elems[off++],
			p: elems[off++],
			GM: theory.GM,
			epoch: jy2k
		};
	}
	// EO orbital

	// update state elements in elems at offset and return array
	function state(solver, theory, jy2k, elems, addGM, addEpoch, off)
	{
		off = off || 0;
		jy2k = jy2k || 0;
		elems = elems || [];
		// call main theory to fill elements
		vsop(solver, theory, jy2k, elems, addGM, addEpoch, off);
		// create orbit object from vsop array
		var orbit = new Orbit({
			a: elems[off+0],
			L: elems[off+1],
			k: elems[off+2],
			h: elems[off+3],
			q: elems[off+4],
			p: elems[off+5],
			GM: theory.GM,
			epoch: jy2k
		});
		// calculate state vector
		var state = orbit.state(jy2k);
		// update state elements
		elems[off++] = state.r.x;
		elems[off++] = state.r.y;
		elems[off++] = state.r.z;
		elems[off++] = state.v.x;
		elems[off++] = state.v.y;
		elems[off++] = state.v.z;
		// return state object
		return elems;
	}
	// EO state

	// update state elements in elems at offset and return state object
	function position(solver, theory, jy2k, elems, addGM, addEpoch, off)
	{
		off = off || 0;
		jy2k = jy2k || 0;
		elems = elems || [];
		// call main theory to fill elements
		state(solver, theory, jy2k, elems, addGM, addEpoch, off);
		// return state object
		return {
			x: elems[off++],
			y: elems[off++],
			z: elems[off++],
			vx: elems[off++],
			vy: elems[off++],
			vz: elems[off++],
			GM: theory.GM,
			epoch: jy2k
		};
	}
	// EO position

	// Export the main exporter function
	// Call this function for every theory
	exports.VSOP = function VSOP(solver, name, GM, coeffs, toVSOP, givesMeanMotion)
	{
		var theory = {};
		// update raw elements in elems at offset and return elems array
		theory.raw = function vsop_raw(jy2k, elems, addGM, addEpoch, off) {
			return solver(theory, jy2k, elems, addGM, addEpoch, off);
		}
		// update vsop elements in elems at offset and return elems array
		theory.vsop = function vsop_theory(jy2k, elems, addGM, addEpoch, off) {
			return vsop(solver, theory, jy2k, elems, addGM, addEpoch, off);
		}
		// update state elements in elems at offset and return elems array
		theory.state = function vsop_state(jy2k, elems, addGM, addEpoch, off) {
			return state(solver, theory, jy2k, elems, addGM, addEpoch, off);
		}
		// update state elements in elems at offset and return state object
		theory.position = function vsop_position(jy2k, elems, addGM, addEpoch, off) {
			return position(solver, theory, jy2k, elems, addGM, addEpoch, off);
		}
		// update vsop elements in elems at offset and return orbital object
		theory.orbital = function vsop_orbital(jy2k, elems, addGM, addEpoch, off) {
			return orbital(solver, theory, jy2k, elems, addGM, addEpoch, off);
		}
		// update vsop elements in elems at offset and return orbit object
		theory.orbit = function vsop_orbit(jy2k, elems, addGM, addEpoch, off) {
			return new Orbit(orbital(solver, theory, jy2k, elems, addGM, addEpoch, off));
		}
		// Attach static properties
		theory.givesMeanMotion = givesMeanMotion;
		theory.toVSOP = toVSOP;
		theory.coeffs = coeffs;
		theory.GM = GM;
		// short name only
		theory.name = name;
		// Return theory
		return theory;
	}
	// EO exports.VSOP

})(this);;
//***********************************************************
// (c) 2016 by Marcel Greter
// AstroJS VSOP87 utility lib
// https://github.com/mgreter/ephem.js
//***********************************************************
(function(exports) {

	// generic vsop87 solver (pass coefficients and time)
	// this is basically a one to one translation from the official
	// fortran code in vsop87.f at around line 185. Only change is
	// that I took out the multiplication for the summands and apply
	// it after the sum has been calculated. IMO this should be a bit
	// faster than the original implementation, but not sure if the
	// precision will suffer from that change.
	function vsop87_theory(theory, jy2k, elems, addGM, addEpoch, off)
	{
		off = off || 0;
		jy2k = jy2k || 0;
		elems = elems || [];
		// get the coefficients
		var coeffs = theory.coeffs;
		// want in thousand years
		var t = jy2k / 1000, orb = {},
			u, cu, tt = [0, 1, t, t*t];
		// reuse old multiplications
		// fortran t(x) array starts at -1!
		// therefore t(it) = tt[it+1] (js)
		tt[4] = tt[3] * t, tt[5] = tt[4] * t, tt[6] = tt[5] * t;
		// do a cheap test if coefficients are from the main vsop87
		// theories. All other [a-e] only need 3 to calculate the
		// full 6 elements (velocity is calculated from position).
		var main = 'a' in coeffs;
		// calculate poisson series
		for (var v in coeffs) {
			// init result holders
			orb[v] = 0;
			if (!main) orb['v'+v] = 0;
			// loop all coefficients for all powers (t^0, t^1, t^2, etc.)
			for (var it = 0; it < coeffs[v].length; it += 1) {
				var pow_sum = 0, dpow_sum = 0, coeff = coeffs[v][it];
				for (var i = 0, cl = coeff.length; i < cl; i += 3) {
					// assign coefficients as in fortran code
					// `read (lu,1002,err=500) a,b,c` (line 187)
					var a = coeff[i+0], b = coeff[i+1], c = coeff[i+2];
					// `u=b+c*t(1)` and `cu=dcos(u)`
					u = b + c * t, cu = Math.cos(u);
					// `r(ic)=r(ic)+a*cu*t(it)`
					pow_sum += a * cu * tt[it+1];
					// condition for `if (iv.eq.0) goto 200`
					// calculation for `t(it)*a*c*su` (line 194)
					// note to myself: tt[it]*it != tt[it+1]
					if (!main) dpow_sum += tt[it]*it*a*cu - tt[it+1]*a*c*Math.sin(u);
				}
				// this is the step for r(ic)=r(ic)+(...) (line 191)
				orb[v] += pow_sum; /*t(it)*/;
				if (!main) orb['v'+v] += dpow_sum / 365250;
			}
		}
		// normalize angles
		if ('L' in orb) {
			orb.L = orb.L % (Math.PI * 2);
			if (orb.L < 0) orb.L += (Math.PI * 2);
		}
		if ('l' in orb) {
			orb.l = orb.l % (Math.PI * 2);
			if (orb.l < 0) orb.l += (Math.PI * 2);
		}
		if ('b' in orb) {
			orb.n = orb.n % (Math.PI * 2);
			if (orb.n < 0) orb.n += (Math.PI * 2);
		}
		// set orbital epoch
		orb.epoch = jy2k;
		// return orbital
		return orb;
	}
	// EO vsop87_theory

	// Export the main export function
	// Call this function for each theory
	exports.VSOP87 = function(name, GM, coeffs)
	{
		// export generic VSOP theory with solver attached
		return exports.VSOP(vsop87_theory, name, GM, coeffs);
	}
	// EO exports.VSOP87

})(this);;
(function(vsop87b) {;
// generated by vsop87.pl
vsop87b.mer = VSOP87('mer', 39.4769329861321, {
	l: [[4.40250710144,0,0,0.40989414977,1.48302034195,26087.9031415742,0.050462942,4.47785489551,52175.8062831484],[26087.9031368553,0,0,0.01131199811,6.21874197797,26087.9031415742]],
	b: [[0.11737528961,1.98357498767,26087.9031415742,0.02388076996,5.03738959686,52175.8062831484,0.01222839532,3.14159265359,0]],
	r: [[0.39528271651,0,0,0.07834131818,6.19233722598,26087.9031415742]]
});
;
// generated by vsop87.pl
vsop87b.ven = VSOP87('ven', 39.4770230655563, {
	l: [[3.17614666774,0,0,0.01353968419,5.59313319619,10213.285546211],[10213.2855462164,0,0]],
	b: [[0.05923638472,0.26702775812,10213.285546211]],
	r: [[0.72334820891,0,0]]
});
;
// generated by vsop87.pl
vsop87b.ear = VSOP87('ear', 39.477046459361, {
	l: [[1.75347045673,0,0,0.03341656453,4.66925680415,6283.0758499914],[6283.0758499914,0,0]],
	b: [[2.7962e-006,3.19870156017,84334.6615813083]],
	r: [[1.00013988784,0,0,0.01670699632,3.09846350258,6283.0758499914]]
});
;
// generated by vsop87.pl
vsop87b.mar = VSOP87('mar', 39.4769391722243, {
	l: [[6.20347711581,0,0,0.18656368093,5.0503710027,3340.6124266998,0.01108216816,5.40099836344,6681.2248533996],[3340.61242700512,0,0,0.01457554523,3.60433733236,3340.6124266998]],
	b: [[0.03197134986,3.76832042431,3340.6124266998]],
	r: [[1.53033488271,0,0,0.1418495316,3.47971283528,3340.6124266998],[0.01107433345,2.03250524857,3340.6124266998]]
});
;
// generated by vsop87.pl
vsop87b.jup = VSOP87('jup', 39.5146186826235, {
	l: [[0.59954691494,0,0,0.09695898719,5.06191793158,529.6909650946],[529.69096508814,0,0]],
	b: [[0.02268615702,3.55852606721,529.6909650946]],
	r: [[5.20887429326,0,0,0.25209327119,3.49108639871,529.6909650946],[0.0127180152,2.64937512894,529.6909650946]]
});
;
// generated by vsop87.pl
vsop87b.sat = VSOP87('sat', 39.4882123322459, {
	l: [[0.87401354025,0,0,0.11107659762,3.96205090159,213.299095438,0.01414150957,4.58581516874,7.1135470008],[213.2990952169,0,0,0.01297370862,1.82834923978,213.299095438]],
	b: [[0.04330678039,3.60284428399,213.299095438]],
	r: [[9.55758135486,0,0,0.52921382865,2.39226219573,213.299095438,0.01873679867,5.2354960466,206.1855484372,0.01464663929,1.64763042902,426.598190876],[0.0618298134,0.2584351148,213.299095438]]
});
;
// generated by vsop87.pl
vsop87b.ura = VSOP87('ura', 39.4789600424755, {
	l: [[5.48129294297,0,0,0.09260408234,0.89106421507,74.7815985673,0.01504247898,3.6271926092,1.4844727083],[74.7815986091,0,0]],
	b: [[0.01346277648,2.61877810547,74.7815985673]],
	r: [[19.21264847206,0,0,0.88784984413,5.60377527014,74.7815985673,0.03440836062,0.32836099706,73.297125859,0.0205565386,1.7829515933,149.5631971346],[0.01479896629,3.67205697578,74.7815985673]]
});
;
// generated by vsop87.pl
vsop87b.nep = VSOP87('nep', 39.4786500913706, {
	l: [[5.31188633046,0,0,0.0179847553,2.9010127389,38.1330356378,0.01019727652,0.48580922867,1.4844727083],[38.13303563957,0,0]],
	b: [[0.03088622933,1.44104372644,38.1330356378]],
	r: [[30.07013205828,0,0,0.27062259632,1.32999459377,38.1330356378,0.01691764014,3.25186135653,36.6485629295]]
});
;
})(vsop87b)
/* crc: 3FC29337E7FF3A8FCB97F60832F6E1BA */
